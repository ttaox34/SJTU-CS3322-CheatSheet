# 1. 关系代数

## 1.1 关系模型的基本概念

<img src=".\assets\PixPin_2024-12-26_19-31-35.png" style="zoom: 25%;" />

*   **关系模式:** 对关系的描述，由关系名及其属性集合组成，记做$R(A_1,A_2,\cdots,A_n)$。
*   **关系名:** 表的名称。
*   **关系:** 元组的集合，可以看作一张二维表。
*   **属性:** 表中的一列。
*   **属性名:** 列的名称。
*   **属性域:** 一组具有相同数据类型的值的集合，属性的取值范围。
*   **属性值:** 属性的具体取值。
*   **元组:** 表中的一行，各个属性的一次取值。
*   **分量:** 元组中的一个属性值。

## 1.2 关系模型的键

*   **超键 (super key):** 能唯一标识一个元组的属性组。
*   **候选键 (candidate key):** 不含多余属性的**超键**。
*   **主键 (primary key):** 被数据库设计者选中的，用来唯一标识元组的**候选键**。主键的值不能为空，也不能重复。
*   **外键 (foreign key):** 一个关系中的属性或属性组，其值必须匹配另一个关系中**主键**的值。外键用于建立和加强两个关系之间的联系。

## 1.3 关系完整性约束

*   **实体完整性约束 (entity integrity constraint):** 主键不能为空值，也不能重复。如果是复合主键，则所有组成主键的属性都不能为空。
*   **参照完整性约束 (referential integrity constraint):** 外键要么为空，要么必须引用另一个关系中已存在的主键值。
    *   删除规则：如果一个被引用的实体要被删除，可以禁止删除（被引用时不能删）；
    *   插入规则：如果一个实体引用了另一个实体，那么被引用的实体必须存在。
*   **用户定义完整性约束 (user-defined integrity constraint):** 用户根据具体应用场景定义的其他约束条件，例如非空约束、唯一约束等。

## 1.4 关系运算

### 1.4.1 基本关系代数

*   **选择 (σ):** 从关系中选取满足条件的元组。
    *   $\sigma_p(R)=\{t|t\in R\wedge p(t)=\mathrm{True}\}$
    *   p 为选择谓词，是由逻辑运算符（与∧、或∨、非¬）连接原子表达式构成的公式。
    *   原子表达式形式：X Θ Y，其中 X, Y 为属性名、常量或函数值，Θ 为比较运算符（=、>、<、≥、≤、≠）。
*   **投影 (π):** 从关系中选取指定的**属性列**组成新的关系，并去除重复元组。
    *   $\Pi_{A_1,A_2,...,A_k}(R)=\{t[A_1,A_2,...,A_k]|t\in R\}$
*   **并 (∪):** 返回两个关系所有元组的集合，两个关系必须具有**相同个数的、一一对应的属性和对应的属性域**。
    *   $R\cup S=\{t\mid t\in R\vee t\in S\}$
    *   Union：去重
    *   Union all：不去重
*   **差 (-):** 返回属于第一个关系但不属于第二个关系的元组，两个关系必须具有**相同个数的、一一对应的属性和对应的属性域**。
    *   $R-S=\{t\mid t\in R\wedge t\notin S\}$
*   **笛卡尔积 (×):** 返回两个关系所有元组的组合。
    *   $R\times S=\{(t,q)\mid t\in R\wedge q\in S\}$
    *   $(t,q)$ 为 R 中元组 t 和 S 中元组 q 拼接在一起得到的元组。
    *   $R\times S$ 中有 $|R|\times|S|$ 个元组。
*   **重命名 (ρ):** 将关系或其属性重命名。
    *   $\rho_{S(A_{1},A_{2},...,A_{n})}(R)$
    *   将关系 R 重命名为 S，并将其属性依次重命名为 A1, A2, ..., An。
    *   $\rho_S\left(R\right)$ 将关系 R 重命名为 S，不修改属性名。

### 1.4.2 附加关系代数

*   **交 (∩):** 返回两个关系中相同的元组，两个关系必须具有**相同个数的、一一对应的属性和对应的属性域**。
    
    *   $R\cap S=\{t\mid t\in R\wedge t\in S\}$
    *   交运算（∩）可以通过差运算（−）来表示：$R\cap S=R-(R-S)$
*   **连接 (⋈):** 基于两个关系的共同属性将它们组合起来。
    
    *   $R\Join_pS=\{(t,q)\mid t\in R\wedge q\in S\wedge p((t,q))=\mathrm{True}\}$
    *   p 为选择谓词。
    *   连接运算（⋈）可通过组合笛卡尔积运算（×）和选择运算（σ）来表示。
    *   **等值连接**：连接条件中谓词为 “=” 的连接。
    *   **自然连接**：一种特殊的等值连接，连接条件是属性名相同的列做等值连接。
*   **外连接:** 连接的扩展，可以处理缺失值。
    *   左外连接 (⟕): 保留左侧关系的所有元组。
    *   右外连接 (⟖): 保留右侧关系的所有元组。
    *   全外连接 (⟗): 保留两侧关系的所有元组。
*   **赋值 (←):** 将关系代数表达式的结果赋给一个临时关系变量。
*   **除 (÷):** 用于查询包含所有指定属性值的元组。
    *   若 $R(A_1,A_2,\cdots,A_m,B_1,B_2,\cdots,B_n)$ 和 $S(B_1,B_2,\cdots,B_n)$ 是两个关系，则 $R\div S$ 的属性为 $A_1,A_2,\cdots,A_m$，且 $R\div S = \{t|t\in \Pi_{A_1,A_2,\cdots,A_m}(R) \land (\forall q \in S,(t,q)\in R)\}$。

    *   除运算 (÷) 会返回 $R$ 中在属性 $A_1,A_2,\cdots,A_m$ 上的元组 $t$，其中元组 $t$ 和关系 $S$ 中的任意元组 $q$ 的组合都会出现在关系 $R$ 中。

    *   如果 $S$ 中有 $R$ 中没有的属性，则无法进行除运算。

### 1.4.3 扩展关系代数

*   **广义投影:** 允许在投影列表中使用算术运算、字符串函数等对属性进行操作。
    *   $\prod_{F_1,F_2,...,F_k}(R)$
    *   其中 $F_1,F_2,...,F_k$ 可以是常量、变量、运算符、函数等。
*   **聚集:** 对关系中的元组按某个属性进行汇总。
    *   $\mathcal{G}_{F_1(A_1),F_2(A_2),...,F_k(A_k)}(R)$
    *   其中 $A_i$ 是要汇总的属性列，$F_i$ 是聚集函数，例如：count, sum, avg, min, max。
*   **分组:**  先对关系进行分组，然后在每个组上进行聚集运算。
    *   $_{G_{1},G_{2},...,G_{l}}\mathcal{G}_{F_{1}(A_{1}),F_{2}(A_{2}),...,F_{k}(A_{k})}(R)$
    *    $G_i$ 是用来分组的一系列属性，为 $R$ 中的列，在这些列上取值都相同的元组将被分到同一组
*   **排序:**  将关系中的元组按照一个或多个属性进行排序。
    *   $\tau_{A_1,A_2,...A_k}(R)$
    *   其中 $A_i$ 是排序属性。
    *   首先将 $R$ 中的元组按照 $A_{1}$ 的值排序，对于 $A_{1}$ 列取值相同的元组，按照 $A_{2}$ 的值排序，以此类推。

### 1.4.4 运算优先级

*   从左到右，括号内的运算具有最高优先级

# 2. SQL 语句

## 2.1 SQL 语句概述

*   **SQL 语句类型**
    *   数据定义语言 (DDL)：定义数据库的结构，例如：`CREATE`, `ALTER`, `DROP`。
    *   数据操作语言 (DML)：操作数据库中的数据，例如：`SELECT`, `INSERT`, `UPDATE`, `DELETE`。
    *   数据控制语言 (DCL)：控制数据库的访问权限，例如：`GRANT`, `REVOKE`。
    *   事务控制：控制事务的执行，例如：`COMMIT`, `ROLLBACK`。
    *   存储过程和函数：预编译的 SQL 代码块，可以重复使用。
    *   触发器：在特定的数据库事件发生时自动执行的 SQL 代码块。
*   **SQL 是一种用户接口语言:** 用户通过 SQL 语句与数据库进行交互。
*   **触发器的优点:**
    * 业务逻辑与数据库逻辑分离
    * 提高执行效率
    * 保证数据完整性

## 2.2 数据定义

*   **创建表**：`CREATE TABLE` 语句
    *   指定表名、列名、数据类型、列级完整性约束、表级完整性约束
    *   常用数据类型：`CHAR(n)`, `VARCHAR(n)`, `INT`, `SMALLINT`, `BIGINT`, `FLOAT`, `DOUBLE`, `DECIMAL(p,d)`, `BOOLEAN`, `DATE`, `TIME`, `TIMESTAMP`

    ```sql
    CREATE TABLE <表名> (
    <列名> <数据类型> [列级完整性约束]...[列级完整性约束]
    [, <列名> <数据类型> [列级完整性约束]...[列级完整性约束]]
    ...
    [, <列名> <数据类型> [列级完整性约束]...[列级完整性约束]]
    [, 表级完整性约束]
    ...
    [, 表级完整性约束]
    );
    ```

*   **表操作**
    *   MySQL 基本构建：数据库 (database) 包含多个数据表 (table)
        *   `create database`：创建数据库
        *   `use database`：使用数据库
        *   `create table`：创建表
        *   `show tables`：查看数据库中所有的表
        *   `desc table`：查看表中的内容
    *   Student, Course, CourseSelection 表的创建
        *   列级完整性约束：`NOT NULL`
        *   表级完整性约束：`PRIMARY KEY`, `UNIQUE`, `FOREIGN KEY`
*   **修改表**：`ALTER Table`
    *   添加列：`ALTER Table <表名> ADD [COLUMN] <列名> <数据类型>`
    *   删除列：`ALTER Table <表名> DROP [COLUMN] <列名> [RESTRICT | CASCADE]`，`RESTRICT` (限制删除)、`CASCADE` (级联删除)
    *   修改列：`ALTER Table <表名> CHANGE COLUMN <列名> <列名> <数据类型>`
*   **删除表**：`DROP Table <表名> [, <表名>]...[, <表名>]`
    *   注意表之间的依赖关系，可能需要先删除依赖的表或外键约束

## 2.3 数据查询

*   **关系运算**
    
    *   基本关系代数：选择、投影、并、差、笛卡尔积、重命名
    *   附加关系代数：交、连接、赋值、除
    *   扩展关系代数：广义投影、聚集、分组、排序
    
* **数据查询 `SELECT` 语句**

  ```sql
  SELECT [ALL | DISTINCT] select_expr [, select_expr] ... [into_option]
      [FROM table_references]
      [WHERE where_condition]
      [GROUP BY {col_name | expr | position}, ...] [HAVING where_condition]
      [ORDER BY {col_name | expr | position} [ASC | DESC]
  ```

  *   `SELECT` 子句：指定要显示的属性列
      *    `DISTINCT`：查询结果会消除取值重复的行
      *   广义投影：允许在 `SELECT` 列表中使用表达式，例如：算术运算、函数
  *   `FROM` 子句：指定表名或视图名
  *   `WHERE` 子句：指定选择条件
  *   `GROUP BY` 子句：指定分组属性
  *   `HAVING` 子句：指定分组筛选条件
  *   `ORDER BY` 子句：指定排序顺序 (`ASC` 升序，`DESC` 降序)

*   **选择条件**
    *   常用谓词：`=`, `>`, `<`, `>=`, `<=`, `!=`, `!>`, `!<`, `NOT + 上述比较符号`, `BETWEEN AND`, `NOT BETWEEN AND`, `IN`, `NOT IN`, `IS NULL`, `IS NOT NULL`
    *   逻辑运算：`AND`, `OR`
    *   字符串匹配：`LIKE`, `NOT LIKE`, `%` (任意多个字符), `_` (任意一个字符), `ESCAPE` (转义字符)
    
*   **聚集操作**
    *   聚集函数：`COUNT`, `SUM`, `AVG`, `MAX`, `MIN`
    *   `COUNT(*)`：统计元组个数
    *   未分组：聚集函数作用于整个查询结果
    *   分组：聚集函数分别作用于每个组

*   **分组操作**
    
    ```sql
    select student_id, avg(grade) from courseselection group by student_id having avg(grade)>80
    ```
    
    *   `GROUP BY` 子句：将满足条件的元组按指定列分组
    *   `HAVING` 子句：对分组进行筛选
    
*   **排序操作**
    *   `ORDER BY` 子句：将查询结果按指定列排序
    *   `DESC`：降序
    *   `ASC`：升序（默认）

*   **连接操作**
    
    *   涉及多个表的查询
    *   在 `FROM` 子句中指定需要连接的表，在 `WHERE` 子句中指定连接条件
    *   连接条件的常见格式：
        
        ```sql
        [<表名1>.]<列名1> <比较运算符> [<表名2>.]<列名2>
        [<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名2>.]<列名3>
        ```
    
    ```sql
    select course_name from student, course, courseselection
        where student.student_id = courseselection.student_id and
        course.course_id = courseselection.course_id and
        student.student_name='David' and
        courseselection.grade>60;
    ```

## 2.4 数据更新

*   插入数据：`INSERT INTO <表名> [(<列名1 > [, <列名2>]...[, <列名n>])] VALUES (<常量1> [, <常量2>]...[, <常量n>]))`
    
    *   将一个新元组插入到指定表中
    *   对于没有在 `INTO` 子句中出现的列，新元组在这些列上的取值为空值
    
    ```sql
    insert into student [student_id, student_name, gender, age, department] values ('100010', 'Henry', 1, 30, 'CS')
    ```
    
* 删除数据：`DELETE FROM <表名>(WHERE <条件>)`

  *   删除指定表中满足 `WHERE` 子句中条件的元组
  *   如果不包含 `WHERE` 子句，则表中的所有元组都将被删除

  ```sql
  delete from student where student_id='100010';
  ```

* 修改数据：`UPDATE <表名> SET <列名1>=<表达式1>, <列名2>=<表达式2>,...<列名n>=<表达式n> WHERE <条件>`

  *   删除指定表中满足 `WHERE` 子句中条件的元组
  *   如果不包含 `WHERE` 子句，则表中的所有元组都将被删除

  ```sql
  update student set age=31 where student_id='100010';
  ```

* 执行更新操作时会检查完整性约束

*   **总结：关系代数与 SQL**

| 关系代数运算     | 对应的 SQL 语句 | 关系代数运算 | 对应的 SQL 语句 |
| :--------------- | :-------------- | :----------- | :-------------- |
| 选择运算 (σ)     | `WHERE`         | 连接运算 (∞) | `JOIN`          |
| 投影运算 (π)     | `SELECT`        | 赋值运算 (←) | `AS`            |
| 并运算 (∪)       | `UNION`         | 除运算 (÷)   | `NOT EXISTS`    |
| 差运算 (-)       | `EXCEPT`        | 去重运算 (δ) | `DISTINCT`      |
| 笛卡尔积运算 (×) | `FROM`          | 广义投影运算 | `SELECT`        |
| 重命名运算 (ρ)   | `AS`            | 聚集运算 (G) | 聚集函数        |
| 交运算 (∩)       | `INTERSECT`     | 分组运算 (G) | `GROUP BY`      |

## 2.5 约束

*   关系数据库中的约束保证了对数据库操作的任何修改都不会违反数据一致性。
*   约束类型：
    *   实体完整性约束(主键)：主键
    *   参照完整性约束(外键)：外键
    *   自增长约束：`AUTO_INCREMENT`，通常用于主键，每次插入新记录时自动生成一个唯一的数字值，例如`student_id INTEGER NOT NULL AUTO_INCREMENT`
    *   默认值约束：`DEFAULT`，例如`home_university VARCHAR(50) DEFAULT 'Xi'an Jiaotong University'`
    *   检查约束：`CHECK`，例如`age INTEGER CHECK (age > 0)`

## 2.6 索引

*   **定义**：索引可以加速查询操作，在某属性上建立索引，可以快速定位到在该属性上取值的元组。用户可以在一个表上建立一个或多个索引，以加速查询。
*   类型：数据库中的索引有很多类型，包括B+树索引、散列索引、位图索引等。
*   **语法**：
    *   创建索引：`CREATE INDEX <索引名> ON <表名> (<列名>[升降序] [, <列名>[升降序], ..., <列名>[升降序], ])`，其中`ASC`表示升序，`DESC`表示降序，例如`CREATE INDEX name_index ON People (name ASC)`
    *   删除索引：`DROP INDEX <索引名> ON <表名>` 或 `ALTER TABLE <表名> DROP INDEX <索引名>`
*   优缺点：
    *   优点：提高查询速度。
    *   缺点：增加空间需求；插入、更新和删除时需要维护索引，有额外开销；可能导致过度优化（查询优化器需要花费更多时间来选择最佳的索引）。

## 2.7 视图

* **定义**：视图是一种“虚关系”，实际查询时需要根据定义查询底层关系，当存在大量这样的查询时会有较高的成本。

*   **语法**：
    
    *   创建视图：`CREATE VIEW <视图名> [<列名> (, <列名>, ...)] AS <子查询>`
    *   删除视图：`DROP VIEW <视图名>`
    *   查询视图：`SELECT ... FROM <视图名> WHERE ...`
    
    ```sql
    create view total as 
        select student.student_id as student_id, student.student_name as student_name, student.age as age, course.course_name as course_name, courseselection.grade as grade, courseselection.year as year, courseselection.term as term 
        from student, course, courseselection 
        where student.student_id = courseselection.student_id and course.course_id = courseselection.course_id;
    ```
    
* 物化视图：某些数据库支持物化视图，像存储表一样将创建的视图关系“物化”存储在数据库中。物化视图的创建、修改与删除语法同视图类似，区别是多了关键字 `MATERIALIZED`。

*   视图更新：
    *   **注意**：在MySQL中，可以对视图进行更新，本质上会对视图的表中的数据进行更新。
    *   优势：简化操作；数据抽象；安全性。
    *   劣势：错误风险；性能问题。

## 2.8 存储过程

*   **定义**：存储过程和函数是事先经过编译并存储在数据库中的一段SQL语句的集合，可以对一段代码进行封装，以便日后调用。
*   **创建存储过程**：

```sql
DELIMITER //
CREATE PROCEDURE <存储过程名> ([参数, ..., 参数])
BEGIN
<SQL 语句>
END <终止符>
DELIMITER;
```

*   通过`CALL`语句加存储过程名来**调用存储过程**。
*   示例：

```sql
DELIMITER // -- 定义语句的结束标记，默认为;

CREATE PROCEDURE RegisterCourse (IN p_student_id CHAR(10), IN p_course_id VARCHAR(10), IN p_grade INTEGER, IN p_year INTEGER, IN p_term INTEGER) -- 参数列表
BEGIN
    -- 声明必须放在最前面
    DECLARE v_student_count INT;
    DECLARE v_course_count INT;
    DECLARE v_registered_count INT;

    -- 变量赋值
    SELECT COUNT(*) INTO v_student_count FROM Student WHERE student_id = p_student_id;
    SELECT COUNT(*) INTO v_course_count FROM Course WHERE course_id = p_course_id;

    -- 控制判断
    IF v_student_count > 0 AND v_course_count > 0 THEN
        SELECT COUNT(*) INTO v_registered_count FROM CourseSelection
        WHERE student_id = p_student_id
          AND course_id = p_course_id
          AND year = p_year
          AND term = p_term;

        IF v_registered_count = 0 THEN
            INSERT INTO CourseSelection(student_id, course_id, grade, year, term)
            VALUES(p_student_id, p_course_id, p_grade, p_year, p_term);
        ELSE
            UPDATE CourseSelection
            SET grade = p_grade
            WHERE student_id = p_student_id
              AND course_id = p_course_id
              AND year = p_year
              AND term = p_term;
        END IF;
    END IF;
END //
DELIMITER ;

CALL RegisterCourse('S000009596', 'C00000100', 85, 2023, 2); -- 调用存储过程
```

*   **参数**：

    *   `IN`：输入参数。调用存储过程时必须提供的值。
    *   `OUT`：输出参数。存储过程结束后返回给调用者的值。
    *   `INOUT`：输入/输出参数。既可以作为输入也可以作为输出。

*   **查看存储过程**：`SHOW PROCEDURE STATUS WHERE Db='your_database_name';`

*   **删除存储过程**：`DROP PROCEDURE [IF EXISTS] procedure_name;`

*   **变量声明**：`DECLARE variable_name data_type [DEFAULT default_value];`

*   **变量赋值**：`SET variable_name = value;` 或 `SELECT <SQL语句> INTO variable_name FROM <表名>;`

*   **控制判断**：

    * ```sql
      IF condition THEN
      	-- statements
      ELSEIF another_condition THEN
      	-- other statements
      ELSE
      	-- more statements
      END IF;
      ```

    * ```sql
      CASE value
      WHEN value1 THEN
      	-- statements
      WHEN value2 THEN
      	-- other statements
      ELSE
      	-- default statements
      END CASE;
      ```


* **循环**：

  * ```sql
    WHILE condition DO
    -- statements
    END WHILE;
    ```

* **调试**：

  * ```sql
    SET @month_result = '';
    CALL MonthNameFromDays(45, @month_result);
    SELECT @month_result;
    ```

## 2.9 游标

*   游标：用于遍历并逐行处理查询结果集。
    *   声明游标：`DECLARE cursor_name CURSOR FOR SELECT_statement;`
    *   打开游标：`OPEN cursor_name;`
    *   获取数据：`FETCH cursor_name INTO variable_name;`
    *   关闭游标：`CLOSE cursor_name;`

```sql
DELIMITER //
CREATE PROCEDURE ProcessData()
BEGIN
    -- 变量声明必须放在最前面
    DECLARE count INT;
    DECLARE id CHAR(10);
    DECLARE name VARCHAR(50);
    DECLARE cur CURSOR FOR SELECT student_id, student_name FROM Student ORDER BY age;
    
    SET count = 0;
    
    OPEN cur; -- 打开游标
    WHILE count<10 DO
        FETCH cur INTO id, name;
        SELECT CONCAT(id, ' ', name);
        SET count = count + 1;
    END WHILE;
    CLOSE cur; -- 关闭游标
END //
DELIMITER ;
```

## 2.10 函数

*   定义：函数是一个预编译的SQL代码段，它可以接受参数、执行操作并返回一个值。函数通常用于计算并返回单个值，而不是结果集。
*   创建函数：

```sql
CREATE FUNCTION <函数名>([参数, ..., 参数])
RETURN <数据类型>
BEGIN
<SQL语句>
END<终止符>
```

*   示例：

```sql
DELIMITER //
CREATE FUNCTION AddTwoNumbers (a INT, b INT)
RETURNS INT
DETERMINISTIC
BEGIN
	RETURN a + b;
END //
DELIMITER ;

SELECT AddTwoNumbers(5, 3); -- 调用函数，返回8
```

* 存储过程和函数的区别

  *   存储过程可以通过`OUT`或`INOUT`参数返回多个值，而函数只能返回`RETURNS`子句中指定的某一类型的单值或表对象。

  *   存储过程的参数可以为`IN`、`OUT`或`INOUT`，而函数的参数只能是`IN`类型的。

  *   存储过程可以通过`CALL`语句作为一个独立的部分来调用和执行，而函数可以作为查询语句的一部分来调用。

  *   创建函数时必须指定返回值数据类型,且函数体内必须有一个`RETURNS`语句。

## 2.11 触发器

* **定义:** 触发器是与表相关的特殊的存储过程，在满足特定条件时（例如插入、删除、更新数据）会被触发执行，可以用来保证数据库的完整性。

* **语法:**

  ```sql
  CREATE TRIGGER <触发器名>
  <触发时机> <触发事件> ON <表名>
  FOR EACH ROW
  <触发动作体>
  ```

  *   `DROP TRIGGER <触发器名>`
  *   触发时机：`BEFORE` 或 `AFTER`。
  *   触发事件：`INSERT`, `DELETE`, `UPDATE`。
  *   `FOR EACH ROW`: 对触发事件作用的每一行执行触发动作体。
  *   `OLD` 和 `NEW`: 访问触发事件发生前后的元组的值。

* 示例

  ```sql
  DELIMITER //
  CREATE TRIGGER CheckCourseGrades
  AFTER INSERT ON CourseSelection -- 在选课表上的插入事件建立触发器，触发在插入后发生
  FOR EACH ROW
  BEGIN
      DECLARE avg_grade DECIMAL(5, 2);
      SELECT AVG(grade) INTO avg_grade
      FROM CourseSelection
      WHERE course_id = NEW.course_id
          AND year = NEW.year
          AND term = NEW.term; -- NEW 指代新插入的记录
      IF avg_grade < 60 THEN
          INSERT INTO ExamExceptions (student_id, course_id, year, term, average_grade)
          VALUES (NEW.student_id, NEW.course_id, NEW.year, NEW.term, avg_grade);
      END IF;
  END;
  //
  DELIMITER ;
  ```

## 2.12 事务控制

*   **事务的定义:** 事务是数据库管理系统 (DBMS) 的一个操作单元或工作单元，具有原子性、一致性、隔离性和持久性 (**ACID**) 特性。
    *   原子性：事务单元全部成功或者全部失败
    *   一致性：一个正确（一致）的状态转移到另一个正确的状态
    *   隔离性：互不干扰，多个事务在并发执行的过程中所得到的结果，和串行执行得到的结果是一致
    *   持久性：永久保持，执行结果不会丢失

*   **事务的控制语句:**
    *   `START TRANSACTION`: 开始事务。
    *   `COMMIT`: 提交事务。
    *   `ROLLBACK`: 回滚事务。一旦rollback，整个事务结束。
    *   `SAVEPOINT sp_name`: 在事务内部设置回滚标记点。
    *   `RELEASE SAVEPOINT`: 删除回滚标记点。
    *   `ROLLBACK TO sp_name`: 将事务回滚到标记点。

## 2.13 用户权限

* **定义:** 控制用户对数据库的访问和操作权限。

*   **控制语句:**
    
    *   创建用户：`CREATE USER 'username'@'hostname' IDENTIFIED BY 'password';`
    *   删除用户：`DROP USER 'username'@'hostname';`
    *   查看用户：`SELECT user, host FROM mysql.user;`
    
*   **权限授予:**
    
    * `GRANT <权限>[, <权限>, ..., <权限>] ON <对象类型><对象名>[, <对象类型><对象名>, ..., <对象类型><对象名>] TO <用户名>[, <用户名>, ..., <用户名>] [WITH GRANT OPTION];`
    
    * `WITH GRANT OPTION`: 允许用户将权限授予其他用户。
    
    * ```sql
      GRANT SELECT
      ON TABLE student_db1.Student
      to 'alice'@'localhost'
      WITH GRANT OPTION;
      ```
    
*   **权限回收:**
    
    * `REVOKE <权限>[, <权限>, ..., <权限>] ON <对象类型><对象名>[, <对象类型><对象名>, ..., <对象类型><对象名>] FROM <用户名>[, <用户名>, ..., <用户名>] [CASCADE|RESTRICT];`
    
    * `CASCADE`: 级联收回权限，即由这些用户授予了以上权限的用户的这些权限也会被收回（MySQL不支持）。
    
    * `RESTRICT`: 不支持级联收回。
    
    * ```sql
      REVOKE SELECT
      ON TABLE student_db1.Student
      FROM 'alice'@'localhost';
      ```
    
*   **用户权限的例子:**
    *   创建用户 `alice` 和 `bob`。
    *   授予 `alice` 对 `Student` 表的 `SELECT` 权限，并允许 `alice` 将该权限授予其他用户。
    *   将 `alice` 授予 `bob` 的权限收回。

**第六部分：其他**

*   **关系数据建模工具 (自动生成DDL):** 以 Enterprise Architecture 为例，演示了如何创建数据库表模型，并生成DDL代码。
*   **课程大纲:** 介绍了课程的进度安排和作业要求。

**总结:**

这门课程主要讲解了SQL语句中的存储过程、触发器、事务与用户控制，以及如何使用关系数据建模工具生成DDL代码。学习这些知识点可以帮助你更好地管理和维护数据库，提高数据库的安全性和完整性。记住多多练习才能熟练掌握。

# 3. 数据库设计与理论

<img src=".\assets\image-20241231110953327.png" alt="image-20241231110953327" style="zoom: 33%;" />

## 3.1 数据库设计流程

1. **需求分析**

2. **设计阶段**

   *   **概念结构设计阶段：** 产出 E-R 模型。

   *   **逻辑结构设计阶段：** 产出关系模式。

   *   **物理结构设计阶段：** 进行物理存储安排，明确存储结构和存取方法。

3. **数据库建设和维护**

*   **设计目标**
  1. 满足用户对数据内容的要求。
  
  2. 提供自然易懂的数据结构。
  
  3. 支持应用所需的数据处理要求和性能目标，如：响应时间、处理时间、存储空间等。
  
*   **概念设计阶段**
    *   通过对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型。
    *   将现实世界的客观事物及其关系抽象为“实体”和“联系”等形式，用于描述业务领域的数据对象及其关系，常采用 **Entity-Relationship (E-R) 模型**。
    *   **E-R模型举例**
        *   **实体：** 学生/课程
        *   **属性：** 学号/课程号
        *   **联系：** 学生与课程实体之间存在“选课”联系
*   **逻辑设计阶段**
    *   在概念模型的基础上，需要进一步考虑这些数据对象在计算机系统中的逻辑表示，形成某个数据库管理系统所支持的数据模型。
    *   常见的逻辑数据模型有**关系模型**、层次模型和网状模型等。
    *   **关系模型**
        *   **关系:** 表
        *   **属性:** 列
        *   **域:** 属性值的类型和范围
        *   **元组:** 行
        *   **属性值:** 表中某个单元的值
*   **物理设计阶段**
    *   在逻辑模型的基础上，具体考虑数据对象如何在数据库管理系统中物理实现。
    *   根据数据库管理系统的特点和处理需要，进行物理存储安排，明确存储结构和存取方法，如：关系表、索引的设计。
    *   需要考虑：**存储空间、存取时间、维护代价** 三者之间的平衡。
*   **数据抽象的层次**
    *   **现实世界** -> **信息世界（概念模型，如E-R模型）** -> **机器世界（数据模型）**
    *   **关系模型、层次模型、网状模型、面向对象模型** 都属于数据模型。
*   **关系数据库设计**
    *   在关系数据库的设计中，一个核心步骤就是将**E-R图转化为关系模式**。
    *   **概念设计** 和 **逻辑设计** 之间存在 **先后关系**。
    *   **E-R模型** 经过 **逻辑设计** 转化为 **关系模型**（**数据模型**）。
    *   **E-R图** 经过 **对应关系** 转化为 **关系模式**（**数据模型实例**）。
*   **E-R图转换为关系模式**
*   **关系模式优化**

## 3.2 E-R模型

### 3.2.1 概念

*   **E-R模型是实体-联系模型（entity-relationship model）的简称**
*   是用于描述现实世界的概念数据模型，也可以用于表示关系数据库的结构
*   在数据库设计领域有着广泛的应用，目前大部分的数据库设计工具和产品均采用E-R模型进行数据库的概念结构设计

### 3.2.2 基本元素

*   **1. 实体和实体集**
    
    *   **实体**：对现实世界中事物数据概念的某种抽象。
        *   通俗地说，实体可以指现实世界的人、物或抽象的概念等。
        *   例如，一个人是实体，一个公司也是实体。
    *   **实体集**：多个具有相同性质的同类实体构成的集合。
        *   例如，一所大学的所有学生是一个实体集，特定的实体称为**实体实例**。
    
*   **2. 属性**
    *   实体集都可以被一组特征来描述，这些用来描述实体集的数据特征被称为实体集的**属性**。
    *   通常不同实体集的属性是不同的。
    *   例如：Student实体集有Sno、Sname、Sgender、Sage和Sdept属性。
    
*   **3. 联系**
    *   正如现实世界中事物之间都有某种联系一样，这些事物在数据库中也必然存在联系
    *   **属于不同实体集的实体之间**，学生实体和课程实体之间的“选课”联系
    *   **属于同一实体集的实体之间**，课程实体和课程实体之间的“先修” 联系
    *   E-R模型中的联系一般是用**动词**来命名
    
*   **标识符：** 可以唯一标识不同的实体集的某一属性。
    *   例如：Student实体集的Sno属性可以唯一标识不同学生，它可以作为Student实体集的标识符。
    
*   **复合标识符：** 当必须选取多个属性的组合来作为实体的唯一标识，称该属性的组合为复合标识符。
    *   SC实体集中，如果仅用Cno作为标识符，则不能区分不同学生（Sno）的选课信息。同理，也找不到其它单个属性用于唯一标识SC实体集。
    *   只有将Sno和Cno组合在一起，才能唯一标识SC实体集，因此Sno和Cno是其复合标识符。
    
### 3.2.3 E-R图

#### 3.2.3.1 基本概念

*   **E-R图是用来描述实体集、属性和联系的图形化表示**
    *   **实体集：** 用**矩形**表示，矩形框内标注实体集名。
    *   **属性：** 用**椭圆形**表示，并用无向边将其与相应的实体集连接起来。
    *   实体集的**标识符**用**下划线**标识出来。
    *   **联系：** 用菱形表示，菱形框内标注联系名，并用无向边分别与有关实体集连接起来，同时**在无向边旁标上联系的类型**（**1:1，1:n 或 m:n**）。
    *   **联系可具有属性：** 如果实体之间的联系也具有属性，则用无向边连接属性和菱形。例如，联系SC有成绩Grade的属性，使用无向边将二者连接。

    <img src=".\assets\PixPin_2024-12-30_18-45-08.png" style="zoom: 33%;" />


#### 3.2.3.2 E-R 联系类型

*   **E-R 联系类型是指实体之间不同关系的形式，常见的联系类型**

    1. **一元联系：** **实体集内部实体之间**的联系称为一元联系。例如，学生实体之间存在同级“管理”的关系（学生管理学生）。
    2. **二元联系：** 两个实体集之间的联系称为二元联系。例如，学生实体集与课程实体集之间存在“选择”课程的联系。一元联系可以看做是特殊的二元联系。
    3. **三元联系：** 三个实体集之间的联系称为三元联系。例如，学生、学校和课程之间存在“学习”的联系，即某学生在某学校学习某课程。

*   **三元联系分解为二元联系**
    
    *   针对三元联系，可以将其分解为二元联系
    *   考虑一个抽象的三元联系R，它将实体集A、B和C联系起来，将该三元联系转换成多个等价的二元联系的具体步骤如下：
        
        1. **用新实体集E替代联系R。**如果联系R有属性，则将这些属性赋给新建的实体集E；为E建立一个特殊的标识性属性。因为每个实体集都应该至少有一个属性或多个属性的集合，以区别实体集中的各个成员
        
        2. **建立三个新的联系RA, RB, RC**。其中，RA是实体集E和A之间的联系；RB是实体集E和B之间的联系；RC是实体集E和C之间的联系
        
        3. **针对联系R中的每个联系（ai, bi, ci），在E中创建一个新实体ei**，ei代表（ai, bi, ci）。然后，在三个新联系集中分别建立新的联系：在RA中插入（ei, ai）；在RB中插入（ei, bi）；在RC中插入（ei, ci）
        
        <img src=".\assets\image-20241230185255469.png" alt="image-20241230185255469" style="zoom: 33%;" />
    
*   **二元联系的不同类型**

    * 在实际应用中，二元联系是最常见的实体联系类型

    *   对于二元联系，又能细分成以下几种类型
        *   **一对一联系（1 : 1）**
        *   **一对多联系（1 : n）**
        *   **多对多联系（m : n）**
        
    * **联系约束：** 一个实体通过联系可以关联到的实体的个数

1. **一对一联系 (1:1)**

    *   如果实体集A中每一个实体最多可以和另一实体集B中的一个实体有关系，反之亦然，则称实体集A和实体集B具有一对一联系，记作1:1。
    *   例如，每个学生只有一张学生证，而一张学生证也只能对应一个学生，学生和学生证实体之间的联系即是“一对一”联系。

2. **一对多联系 (1:n)**
    *   如果实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之相关，则称实体集A与实体集B有一对多联系，记作1:n。
    *   例如，假设一个学校可以录取多名学生，而每名学生只能被一个学校录取，则学校和学生之间建立起的这种“录取”联系就是一个“一对多”联系。

3. **多对多联系 (m:n)**
    *   如果实体集A中的每个实体在实体集B中有n个实体（n≥0）与之相关，反之，实体集B中的每个实体都在实体集A中有m个实体（m≥0）与之相关，则称E和F具有多对多联系，记为m:n。
    *   例如，一个学习选择多门课程，而一门课程也可以被多个学生选择，学生和课程实体集之间的“选择”联系就是一个“多对多”联系。

*   **N元联系类型**
    *   **N元联系：** 涉及N个实体的复杂联系
    *   N个实体之间也存在一对一、一对多、多对多联系
    *   例如，课程、教师、参考书三个实体集，假设一门课可以有若干个教师讲授，使用若干本参考书，而每个教授只讲授一门课，每一本参考书只供一门课程使用，则课程与教师、参考书之间的联系**是一对多的**。
    
*   **例：E-R 图设计**
    
    *   设计一个工厂物资管理的E-R图。物资管理涉及的实体有：
        *   仓库：属性有仓库号、面积、电话号码
        *   零件：属性有零件号、名称、规格、单价、描述
        *   供应商：属性有供应商号、姓名、地址、电话号码、账号
        *   项目：属性有项目号、预算、开工日期
        *   职工：属性有职工号、姓名、年龄、职称
    *   实体之间的联系如下：
        *   一个仓库可以存放多种零件，一种零件可以存放在多个仓库中。用**库存量**来表示某种零件在某个仓库中的数量。
        *   一个仓库有多个职工当仓库保管员，一个职工只能在一个仓库工作。
        *   职工之间具有领导与被领导关系。即仓库主任领导若干保管员。
        *   供应商、项目和零件三者之间具有多对多的联系。即一个供应商可以供给若干项目多种零件，每个项目可以使用不同供应商供应的零件，每种零件可由不同供应商供给。用**供应量**来表示某个供应商对某个项目供应的某个零件的数量。
    *   仓库、零件、项目、职工、供应商之间存在哪些联系？
        *   **一元联系：** 领导
        *   **二元联系：** 工作、存放
        *   **三元联系：** 供应
    
    <img src=".\assets\image-20241230194132309.png" alt="image-20241230194132309" style="zoom: 33%;" />
    
*   **E-R图设计：实体 or 属性**
    *   **实体与属性的划分原则**
        *   为了简化E-R图，现实世界的事物能作为属性对待的，尽量作为属性对待。
        *   两条准则：
            1. 作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性。
            2. 属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。
    *   **举例**
        *   职工是一个实体，职工号、姓名、年龄是职工的属性。职称如果没有与工资、福利挂钩，根据准则（1）可以作为职工实体的属性。如果不同的职称有不同的工资、住房标准和不同的附加福利，则职称作为一个实体更恰当
        *   在医院中，一个病人只能住在一个病房，病房号可以作为病人实体的一个属性；如果病房还要与医生实体发生联系，即一个医生负责几个病房的病人的医疗工作，则根据准则（2）病房应作为一个实体。
    
*   **E-R图设计：属性的放置**
    
    *   **联系属性（relationship attributes）** 通常只用于多对多联系，但也可以用于一对一和一对多联系。

### 3.2.4 约束

*   **约束：** 用于表达数据应具备的性质或者需要满足的限制，为数据增添了语义信息
*   **属性约束：** 域、键
    *   学生的考试成绩在0-100之间
    *   每个学生有且仅有一个学号
*   **联系约束：** 基数、参与度
    *   每个学生只属于一个学院

#### 3.2.4.1 属性约束：域（Domain）

*   **域约束（Domain Constraint）** 限制属性的取值范围
    *   **属性类型（attribute type）：** 工资是非负实数
    *   **逻辑谓词（logical predicate）：** 工号是 [1, 9999] 范围内的整数

#### 3.2.4.2 属性约束：键（Key）

*   **键约束（Key Constraint）**：一组属性的取值能够唯一标识一个实体，则该属性为实体的键（key）
    *   候选键（能唯一标识实体的极小属性集合）、主键、复合键

#### 3.2.4.3 联系约束：基数和参与度

*   **基数（Cardinality）：** 实体参与某一联系的**最大**次数
    *   如：每个学生最多可以选几门课？20
*   **参与度（Participation）：** 实体参与某一联系的**最小**次数
    *   如：每个学生最少要选几门课？0
*   表示方法：`(min, max)`，例如：`(10, 100)` 表示最小基数是 10，最大基数是 100。

<img src=".\assets\image-20241230195052555.png" alt="image-20241230195052555" style="zoom: 33%;" />

*   特殊的最大基数
    *   `max-card(E1, R) = 1 and max-card(E2, R) = 1`：一对一 (1:1)
    *   `max-card(E1, R) = 1 and max-card(E2, R) = N`：一对多 (1:N)
    *   `max-card(E1, R) = N and max-card(E2, R) = 1`：多对一 (N:1)
    *   `max-card(E1, R) = N and max-card(E2, R) = N`：多对多 (N:M)

### 3.2.5 E-R图的集成

*   目的： 多个分E-R图集成为一个E-R图
*   **步骤：**
    *   **合并。** 解决各分E-R图之间的冲突，将分E-R图合并起来生成初步E-R图。
    *   **修改和重构。** 消除不必要的冗余，生成基本E-R图。

1. 合并E-R图

*   子系统E-R图之间的冲突主要有三类：
    *   **属性冲突**
        *   **属性域冲突**，如：学号可以被定义为整数，也可以被定义为字符型
        *   **属性值冲突**，如：体重可以以克为单位，也可以以千克为单位
    *   **命名冲突**
        *   **同名异义**，如：编号可以是课程编号，也可以是学生编号
        *   **异名同义**，如：学号和学生编号
        *   可能发生在实体、联系、属性
    *   **结构冲突**
        *   **同一对象的不同抽象**，如：工资在一些应用中被当作实体，在另一些应用被当作属性
        *   **同一实体包含属性个数和排列次序不同**
        *   **实体间的联系在不同E-R图中类型不同**

2. 消除冗余

*   **冗余的数据是指：** 可以由基本数据导出的数据
*   **冗余的联系是指：** 可以由其他联系导出的联系
*   例如：`Q3 = Q1 * Q2, Q4 = ΣQ5`。所以 Q3 和 Q4 是冗余数据，可以消去。由于 Q3 消去，产品与材料间 m:n 的冗余联系也应消去。
*   **注意：** 不是所有的冗余数据和冗余联系都必须加以消除，有时候为了提高效率，不得不以冗余信息作为代价。
*   解决方法：**规范化理论**

## 3.3 实体集和关系的转换

### 3.3.1 实体集的转换

*   基本操作是将实体集转换为关系表
*   实体集的名称 -> 关系表的表名
*   实体集的属性 -> 关系表的属性（列）
*   实体集的标识符 -> 关系表的主键 
*   联系转换为关系模式，属性为关联实体集的标识符集合及联系自身的属性

### 3.3.2 联系的转换

* **一元联系**: 转换规则与二元联系类似

*   **二元联系**:
    *   **一对一 (1:1)**:
        1. 任选一个关系模式添加另一个关系模式的键和联系自有的属性。
        
           例：Student(Sno, Sname, Sgender, Sage, Sdept, **StuCardID**), StuCard(StuCardID, Cardbalance, CardExp) 或 Student(Sno, Sname, Sgender, Sage, Sdept), StuCard(StuCardID, Cardbalance, CardExp, **Sno**)
        
        2. 添加一个新的关系模式，包含该联系相关的各实体集的标识符以及该联系自有的属性，候选键可以是每个实体集的标识符。
        
           例：添加一个独立的关系模式，即Hold(Sno, StuCardID)，主键为Sno或者StuCardID。
        
    *   **一对多 (1:n)**:
        1. 在**n端**实体集转换成的关系模式中加入1端实体集的标识符和该联系自有的属性。
        
           例：Student(Sno, Sname, Sgender, Sage, Sdept, **SchoolID**), School(SchoolID, SchoolName, SchoolLocation)
        
        2. 添加一个新关系模式，属性是所有与该联系相关的各实体集的标识符以及该联系自有的属性，**主键是n端实体集的标识符**。
        
           例：添加一个独立的关系模式，即 Admission(<u>Sno</u>, SchoolID)。
        
    * **多对多 (m:n)**: 添加一个新的关系模式，属性是两端实体类型的标识符以及该联系自有的属性，键为两端实体集的标识符的组合。
    
      例：SC(<u>Sno</u>, <u>Cno</u>, Grade) 
    
*   **三元联系**: 分解成二元联系，再用二元联系的规则进行转换

## 3.4 规范化设计理论

### 3.4.1 规范化设计概念

*   **目标**: 减少数据冗余和定义一个规范的表间结构，实现数据完整性和一致性。
*   **优点**:
    1. 降低数据存储和维护数据一致性的成本。
    2. 便于设计合理的关系表间的依赖和约束关系，避免插入、删除、更新异常。
    3. 便于设计合理的数据库结构，提高数据库系统的整体性能。
*   **注意**: 规范化程度不是评估关系数据库模式的唯一准则，有时规范的关系模式在实际应用中表现并不好。

### 3.4.2 函数依赖

*   **函数依赖**

    *   定义: 给定关系R(U), X和Y是其列集合U的子集, t和l分别是R中的任意两个元组。如果t[X] = l[X], 则t[Y] = l[Y], 那么称Y函数依赖于X, 或者**X函数决定Y**, 记为X → Y。
    *   **用函数依赖重新定义关系的键**:
        *   候选键: 属性或属性集合K满足: 1. 其他属性函数依赖于K; 2. 其他属性都不函数依赖于K的任一真子集。
        *   主键: 多个候选键中选择一个作为主键。
        *   超键: K → U, 则K为超键。

*   **平凡/非平凡函数依赖**

    *   **平凡函数依赖**: X → Y, 且Y ⊆ X
    *   **非平凡函数依赖**: X → Y, 且Y ⊄ X
    *   所有关系都满足平凡函数依赖，通常所指的函数依赖一般都是指非平凡函数依赖。

*   **完全/部分函数依赖**

    *   **完全函数依赖**: X → Y, 且不存在X的真子集X', 使得X' → Y, 记作$X \overset{f}{\rightarrow} Y$
    *   **部分函数依赖**: X → Y, 但存在X的真子集X', 使得X' → Y, 记作$X \overset{p}{\rightarrow} Y$
    *   例：在关系SC(Sno, Cno, Grade)中，有(Sno,Cno)→ Grade, Sno↛Grade,
        Cno↛Grade，那么有：(Sno,Cno)$\overset{f}{\rightarrow}$Grade, (Sno,Cno)$\overset{p}{\rightarrow}$Sno, (Sno,Cno)$\overset{p}{\rightarrow}$Cno

*   **传递函数依赖**

    *   X → Y, Y ↛ X, Y → Z, 则称Z对X有传递函数依赖
    *   例：在关系Course(Cno, Cname, Cpno, Ccredit)中，如果课程名可以相同，但课程号必须不同，且同一课程名的先修课是相同的。那么有：Cno → Cname, Cname ↛ Cno, Cname → Cpno，则称： Cpno 对 Cno有传递函数依赖

*   **多值依赖**

    *   定义: 对于关系R的属性集U, 设X和Y是U的子集, Z = U - X - Y, 令(x, y, z)表示属性集(X, Y, Z)的元组。如果存在(x, y1, z1)和(x, y2, z2)时, 也存在(x, y1, z2)和(x, y2, z1), 那么称多值依赖X →→ Y在关系R上成立。
    *   简而言之，对于任意的元组a, b且a[X]=b[X]，交换元组a, b的Y属性的值，交换后的元组仍存在于关系R(U)中，则X →→ Y。x值决定了y的取值范围，但y的具体取值与z值无关。
    *   平凡多值依赖: Z为空集
    *   非平凡多值依赖: Z非空
    *   函数依赖是多值依赖的特例(单值依赖)。

    - 例：Sno →→ Phone, Sno →→ Email

    <img src=".\assets\image-20241231104512781.png" alt="image-20241231104512781" style="zoom: 33%;" />

*   **连接依赖 (Join Dependency)**:
    *   如果一个关系可以被分解为若干子关系, 并且对这若干子关系通过连接(Join)操作后得到原始关系, 则连接依赖成立。
    *   多值依赖是连接依赖的特例。

### 3.4.3 关系模式的范式 (Normal Form)

*   **第一范式 (1NF)**: 属性都是不可再分的基本数据项，同一属性中不能有多个值，即关系表中的某个属性不能有多个值或者不能有重复的属性。
    *   在关系数据库中，满足最低要求的范式是第一范式，不满足第一范式的不是关系数据库。

<img src=".\assets\image-20241231104927431.png" alt="image-20241231104927431" style="zoom: 33%;" />

*   **第二范式 (2NF)**: 满足1NF, 且每一个非主属性都完全函数依赖于任何一个候选键。
    *   主属性：包含在候选键中的属性
    *   非主属性：不包含在任何候选键中的属性

<img src=".\assets\image-20241231105136482.png" alt="image-20241231105136482" style="zoom: 33%;" />

*   **第三范式 (3NF)**: 满足1NF, 且不存在非主属性对候选键的传递函数依赖。
    *   3NF包含于2NF
    *   例：若每个系的学生住同一个地方，则以下关系不满足3NF。

<img src=".\assets\image-20241231110038249.png" alt="image-20241231110038249" style="zoom: 33%;" />

<img src=".\assets\image-20241231110238752.png" alt="image-20241231110238752" style="zoom: 33%;" />

*   **巴斯-科德范式 (BCNF)**: 满足3NF, 且任何属性都完全函数依赖于R的候选键(或者说: 若X → Y且Y ⊄ X时X必是超键)。
    *   BCNF与3NF的联系比较紧密，主要体现在以下两个特性
        1. 如果关系模式R满足BCNF，那么该关系模式R必定满足3NF
        2. 如果关系模式R满足3NF，且只有一个候选键，那么R必定满足BCNF
    *   如果一个关系模式R满足BCNF，则说明在函数依赖的范畴内，它已经实现了关系模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常

<img src=".\assets\image-20241231110654163.png" alt="image-20241231110654163" style="zoom: 33%;" />

*   **第四范式 (4NF)**: 满足BCNF, 且消除了多值依赖。

<img src=".\assets\image-20241231110854039.png" alt="image-20241231110854039" style="zoom: 33%;" />

*   **第五范式 (5NF)**: 消除连接依赖。
*   **范式之间的关系**: 5NF ⊂ 4NF ⊂ BCNF ⊂ 3NF ⊂ 2NF ⊂ 1NF

### 3.4.4 数据依赖的公理系统

#### 3.4.4.1 Armstrong 公理系统

*   **逻辑蕴含**：对于满足一组函数依赖 F 的关系模式 R < U, F >，其中任何一个关系 r，如果函数依赖 X → Y 都成立 (即关系 r 中的任意两元组 t, s，若 t[X]=s[X]，则 t[Y]=s[Y])，则称 F 逻辑蕴涵 X → Y，或者称 X → Y 是 F 的逻辑蕴涵。
*   **推理规则:** U={A1, A2, ..., An}是R中所有属性的集合，F是U上的一组函数依赖，有关系模式R<U, F>，对于R<U, F>有以下推理规则：
    *   自反律：若 Y ⊆ X ⊆ U，则 X → Y 为 F 所蕴涵。
    *   增广律：若 X → Y 为 F 所蕴涵，且 Z ⊆ U，则 XZ → YZ 为 F 所蕴涵。
    *   传递律：若 X → Y 和 Y → Z 为 F 所蕴涵，则 X → Z 为 F 所蕴涵。
    *   合并规则：若 X → Y, Y → Z, 则 X → YZ。
    *   分解规则：若 X → Y, Z ⊆ Y, 则 X → Z。
    *   伪传递规则：若 X → Y, WY → Z, 则 XW → Z。
    *   X → A1, A2, ..., An 成立的充分必要条件是 X → Ai (i = 1, 2, 3, ..., n) 成立。

#### 3.4.4.2 闭包及其计算

* **函数依赖集的闭包** (FD Closure)：在关系模式 R < U, F > 中，为 F 所逻辑蕴涵的函数依赖的全体叫作 F 的闭包，记作 $F^+$。简而言之，$F^+$包含了 F 中所有的函数依赖。

* **属性集的闭包** (Attribute Closure)：U = {A1, A2, ..., An} 是关系模式 R 中所有属性的集合，F 是 U 上的一组函数依赖，X ⊆ U，Y ⊆ U，$X_F^+$ = {A|X → A 可由 F 根据 Armstrong 公理系统推出}，则 $X_F^+$ 称为属性集 X 关于函数依赖集 F 的闭包。

*   属性集闭包的计算算法：
    *   输入：X, F
    *   输出：$X_F^+$ 
    *   步骤：
        1. 令 X(0) = X, i = 0.
        2. 求 B，B = {A|(∃V)(∃W)(V → W ∈ F ∧ V ⊆ X(i) ∧ A ∈ W)}。（对X(i)的每个子集，依次检查相应的函数依赖,将依赖它的属性加入B）
        3. 令 X(i+1) = B ∪ X(i).
        4. 如果 X(i+1) 和 X(i) 不相等，则 i = i + 1，返回步骤 2。
        5. 如果 X(i+1) 和 X(i) 相等，或者 X(i) 和 U 相等，则 X(i) 就是 $X_F^+$ ，算法终止。
    
    <img src=".\assets\image-20241231113332148.png" alt="image-20241231113332148" style="zoom: 33%;" />
    
*   属性集闭包的使用：
    *   判断函数依赖是否成立：X → Y ∈ F+ ⇔ Y ⊆ $X_F^+$
    *   判断键：
        *   如果 $X_F^+$ = U，则 X 是超键。
        *   如果 $X_F^+$ = U 且 X 的任意子集 Z 不满足 $Z_F^+$ = U，则 X 是候选键。

#### 3.4.4.3 函数依赖集的等价和最小函数依赖集

*   函数依赖集的冗余：
    *   一个函数依赖集 F 存在冗余的**函数依赖** (可以从其他函数依赖推理出来)，如 {A→B, B→C, A→C} 中 A→C 是冗余的
    *   一个函数依赖中存在冗余的**属性**，如{A→B, B→C, A→CD} 可以被化简为 {A→B, B→C, A→D}
    
* 函数依赖集的等价：若$F^+=G^+$，则有函数依赖集 F 覆盖 G (或者 G 覆盖 F)，也称 F 和 G 等价。两个函数依赖集等价是指它们的闭包等价。

  *   等价函数依赖集的判定：$F^+=G^+$的充分必要条件是 F ⊆ G+ 和 G ⊆ F+。（F 中的所有函数依赖都能被 G 推导出来 (F ⊆ G+)，并且 G 中的所有函数依赖也都能被 F 推导出来 (G ⊆ F+)）

  <img src=".\assets\image-20241231165211235.png" alt="image-20241231165211235" style="zoom: 40%;" />

* **最小函数依赖集** (最小覆盖 Canonical Cover)：若函数依赖集 F 满足以下 3 个条件，则称 F 为一个极小函数依赖集，亦称为最小函数依赖集或最小覆盖。

  *   F 中任一函数依赖的右部仅含一个属性
  *   F 中不存在这样一个函数依赖 X → A，使得 F 与 F - {X → A} 等价
  *   F 中不存在这样一个函数依赖 X → A，X 有真子集 Z，使得 (F - {X → A}) ∪ {Z → A} 与 F 等价

* 每一个函数依赖集 F 均等价于一个最小函数依赖集 Fm。

* 求最小函数依赖集的算法：
  1. 首先依次检查 F 中的各函数依赖 FDi：使 F 中每一个函数依赖的右部属性单一化。X → Y，若 Y = A1A2A3, ..., An (n ≥ 2)，则用 {X → Aj|(j = 1, 2, ..., n)} 来取代 X → Y。
  2. 然后依次检查 F 中的各函数依赖 FDi：X → A，设 X = B1B2B3, ..., Bm (m ≥ 2)，逐一检查 Bi (i = 1, 2, 3, ..., m)，若 A ∈ (X - Bi)+，则用 X - Bi 代替 X。
  3. 最后依次检查 F 中的各函数依赖 FDi：X → A，令 G = F - {X → A}，若 A ∈ XG+，则从 F 中去掉此依赖。

* F 的最小函数依赖集**不一定是唯一的**，它与对各函数依赖 FDi 以及 X → A 中 X 各属性的处理顺序有关。

## 3.5 规范化设计实现（关系模式的分解）

### 3.5.1 关系模式分解的定义

*   对于关系模式 R < U, F >，它的一个分解是指$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>, ...,R_n<U_n,F_n>\}$，并且满足：
    *   关系不丢失：$U=\cup_{i=1}^nU_i$
    *   模式不冗余：不存在$U_i\subseteq U_j(1\leq i,j\leq n)$
    *   依赖不丢失：Fi 是 F 在 Ui 上的投影，即$F_i=\{X\to Y|X\to Y\in F^+\wedge XY\subseteq U_i\}$
*   分解后的若干模式$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>, ...,R_n<U_n,F_n>\}$与原模式 R < U, F > 等价。
*   关系模式等价分解的概念：
    *   数据等价：分解具有无损连接性 (lossless join)
    *   语义等价：分解要保持函数依赖 (preserve functional dependency)
    *   关系模式等价分解既要保持函数依赖，又要具有无损连接性。

### 3.5.2 分解的无损连接性 (Lossless Join)

*   定义：关系模式 R < U, F > 的一个分解是$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>, ...,R_n<U_n,F_n>\}$，若 R1、R2、...、Rn 自然连接的结果等于R，则分解 ρ 具有无损连接性，ρ 是关系模式 R < U, F > 无损连接分解。
*   例：

<img src=".\assets\image-20241231193908669.png" alt="image-20241231193908669" style="zoom: 33%;" />

*   **检验无损分解的算法** (分解为 2 个以上关系模式时的判定方法)：
    *   输入：关系模式 $R<\{A_1,A_2,...,A_n\},F>,\rho=\{R_1,R_2,...,R_m\}$
    *   输出：确定 ρ 是否为无损分解
    *   步骤：
        1. 构造一个 n 列 m 行的表，每一列对应于属性，每一行对应于分解中的一个关系模式。
        2. 如果 Aj ∈ Ri，则在第 i 行第 j 列上置为 $a_j$，否则置为 $b_{ij}$。
        3. 依次检查 F 中的每一个函数依赖，并修改表中的元素。对于 F 中任一个函数依赖 X → Y，在 X 列上寻找元素相同的行，然后将这些行的 Y 列赋相同符号：如果 Y 列中有 $a_j$，则将剩余的 $b_{ij}$ 都改为 $a_j$；反之则改为 $b_{ij}$ (i 为最小行号)。
        4. 如果有一行为 $a_1 a_2...a_n$，则 ρ 是无损分解，算法结束，退出；否则进行步骤 (5)。
        5. 如果 F 中所有的函数依赖都不能再修改表，且没有发现某行变成 a1a2...an，则 ρ 不是无损分解，算法结束，退出。
*   另一种检验无损分解方法 (分解为 2 个关系模式)：
    *   设 ρ={R1, R2} 是关系模式 R 的一个分解，F 是 R 的函数依赖集，那么 ρ 是 R (关于 F) 的无损分解的充分必要条件是：[(R1 ∩ R2) → R1-R2] ∈ F+ 或 [(R1 ∩ R2) → R2-R1] ∈ F+
    *   R1-R2指属性的差，返回属于R1但不属于R2的属性集
    *   例：R(A,B,C), F={A→B}。ρ1 ={R1(A,B), R2(B,C)} 不是无损分解, ρ2={R1(A,B), R2(A,C)} 是无损分解。

### 3.5.3 分解的保持依赖性

*   定义：如果$F^+=(\cup_{i=1}^nF_i)^+$，则关系模式 R < U, F > 的一个分解$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>, ...,R_n<U_n,F_n>\}$保持函数依赖。

* 无损连接 VS 保持函数依赖

  *   若一个分解具有无损连接性，则它能够保证不丢失信息

  *   若一个分解保持了函数依赖，则它可以减轻或者解决各种异常情况

  *   无损分解和保持函数依赖的分解是两个相互独立的标准
      *   具有无损连接性的分解不一定能够保持函数依赖
      *   保持函数依赖的分解也不一定是无损分解

### 3.5.4 模式分解算法

*   人工分解
    *   优点：对关系模式的语义具有深入理解
    *   缺点：只能对属性较少的关系模式进行分解
*   关系模式分解算法
    *   优点：能够对具有很多属性的关系模式进行自动分解
    *   缺点：缺少对关系模式语义的理解，可能会 “过度分解”
*   **算法一：分解到 3NF，并保持函数依赖的模式分解算法**
    *   输入：关系模式 R < U, F >
    *   输出：$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>, ...,R_m<U_m,F_m>\}$ 保持函数依赖
    *   步骤：
        1. 令 ρ = ∅，计算 F 的最小函数依赖集 Fm。
        2. 令 U0 = ∅，对 U 中的每个属性 Ai，若其不出现在 Fm 中任一函数依赖的左端和右端，令 U0 = U0 ∪ {Ai}。以 U0 为属性集，构造一个新的关系模式 R0，令 ρ = ρ ∪ {R0}，U = U - U0.
        3. 若 X → Y ∈ Fm，且 XY = U，则输出 ρ = ρ ∪ {R}。即 R 为 3NF，算法终止；否则转步骤 (4)。
        4. 若 Fm 中存在左端相同的函数依赖 X → Y1, X → Y2, ..., X → Ym，对其进行合并，令 Fm = (Fm - {X → Y1, X → Y2, ..., X → Ym}) ∪ {X → (Y1 ∪ Y2 ∪ ... ∪ Ym)}。重复步骤 (4)，直到 Fm 不存在左端相同的函数依赖。
        5. 对 Fm 中每个函数依赖 Xi → Yi，令 Ui = Xi ∪ Yi，构造 Ri(Ui)，令 ρ = ρ ∪ {Ri}。
        6. 算法终止，输出 ρ。
*   **算法二：分解到 3NF，既保持无损连接性又保持函数依赖的模式分解。**
    *   输入：关系模式 R < U, F >
    *   输出：$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>, ...,R_m<U_m,F_m>\}$ 保持无损连接性和函数依赖。
    *   步骤：
        1. 基于算法一，求出保持函数依赖的分解 $\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>, ...,R_k<U_k,F_k>\}$。
        2. 若有某个 Ui 包含任意一个候选键，则输出 ρ；否则，选择 R < U, F > 的任一候选键 X，组成新的关系模式 Rk+1 < X, Fx >，输出 ρ ∪ {Rk+1}。
*   **算法三：分解到 BCNF，具有无损连接性的模式分解算法。**
    *   输入：关系模式 R < U, F >
    *   输出：$\rho=\{R_1<U_1,F_1>,R_2<U_2,F_2>, ...,R_m<U_m,F_m>\}$ 保持无损连接性。
    *   步骤：
        1. 令 ρ = {R < U, F >}。
        2. 若 ρ 中各个关系模式都满足 BCNF，转步骤 (4)，否则步骤 (3)。
        3. 任取 ρ 中不满足 BCNF 的模式 Ri(Ui)，F 在 Ui 上的投影为 Fi，由于 Ri(Ui) 不满足 BCNF，则必定存在函数依赖 X → Y ∈ Fi+，其中 X 不是 Ri(Ui) 的候选键，且 Y 不包含于 X。分别以属性集 Ui - {Y} 和 X ∪ Y 构造模式 Ri' 和 Ri''，令 ρ = (ρ - {Ri}) ∪ {Ri', Ri''}，转 (2)。
        4. 算法终止，输出 ρ (由于 U 中的属性个数有限，该算法必然终止)。
    *   R < U, F > 的分解并不是唯一的，这与步骤 (3) 中选择具体的 X → Y 有关。

# 4. 并发控制

## 4.1 并发问题及隔离级别

*   **并发事务：** 多个事务同时访问数据库系统。
*   **并发事务可能引发的问题：**
    *   **脏读：** 一个事务读到了另一个事务未提交的数据。
    
    <img src=".\assets\image-20241231222026987.png" alt="image-20241231222026987" style="zoom: 33%;" />
    
    *   **不可重复读：** 一个事务内多次读取同一数据，但读取到的结果不一致（由于其他事务的修改并提交）。**面对更新操作**。
    
    <img src=".\assets\image-20241231222234057.png" alt="image-20241231222234057" style="zoom:33%;" />
    
    *   **幻读：** 一个事务内多次按相同条件查询，但查询到的结果数量不一致（由于其他事务的插入或删除并提交）。**面对插入和删除操作**。
    
    <img src=".\assets\image-20241231222305786.png" alt="image-20241231222305786" style="zoom:33%;" />
    
    *   **写冲突：** 两个事务同时修改同一数据项，导致数据不一致。
    
    <img src=".\assets\image-20241231222636633.png" alt="image-20241231222636633" style="zoom:33%;" />
*   **并发事务的问题总结：** 读了变化的或者错误的数据项。
*   **并发事务与隔离机制：**
    *   **读未提交（Read Uncommitted）：** 最低的隔离级别，允许脏读，事务可以读取其他未提交事务的更改。
    *   **读提交（Read Committed）：** 只能读取已提交的数据，避免了脏读，但可能出现不可重复读。
    *   **可重复读（Repeatable Read）：** 确保事务执行过程中多次读取同一数据结果相同，防止了不可重复读，但可能出现幻读。
    *   **串行化（Serializable）：** 最高的隔离级别，事务串行执行，防止了脏读、不可重复读和幻读，但并发性能最低。
*   **隔离级别总结：**

    | 隔离级别       | 脏读   | 不可重复读 | 幻读   |
    | :------------- | :----- | :--------- | :----- |
    | 读未提交       | 允许   | 允许       | 允许   |
    | 读已提交       | 不允许 | 允许       | 允许   |
    | 可重复读       | 不允许 | 不允许     | 允许   |
    | 可串行化       | 不允许 | 不允许     | 不允许 |
    | **性能**       | 高     |            |        |
    | **数据一致性** |        |            | 低     |

## 4.2 锁机制

### 4.2.1 锁

* 并发错误来自于对同一数据项的同时读写。锁可以控制某个数据项的读写访问权限。

*   **共享锁（读锁/S锁）：**
    *   事务在数据项d上加共享锁后，只能读取d不能修改d。
    *   其他事务在不对数据项加锁的情况下无法读写d；在加共享锁的情况下可以读取d。
    
*   **互斥锁（写锁/X锁）：**
    *   事务在数据项d上加互斥锁后，可以读写d。
    *   其他事务在不对数据项加锁的情况下无法读写d；也无法对其加共享锁或者互斥锁。
    
*   **锁相容总结：**

    |        | 共享锁 | 互斥锁 |
    | :----- | :----- | :----- |
    | 共享锁 | 相容   | 不相容 |
    | 互斥锁 | 不相容 | 不相容 |

*   **锁的使用方式：**
    *   事务访问数据项前应先加锁：只进行读取操作则申请共享锁，要进行读写操作则申请互斥锁。
    *   授予锁的条件：数据项未被加锁，则允许当前加锁请求；数据项已被加锁，根据相容性处理。
        *   可授予相容的共享锁。
        *   拒绝不相容的加锁请求，申请加锁事务应当等待当前持有锁的事务释放锁。
    *   事务释放锁的两种方式：在执行期间释放锁；在终止时释放锁，包括事务撤销或者完成提交。
    
* **二阶段锁**（Two-Phase Locking, 2PL）协议：试图解决**不可重复读**。

  <img src=".\assets\image-20241231223454059.png" alt="image-20241231223454059" style="zoom:33%;" />

  *   **加锁阶段（Locking Phase）：** 事务可以获取所需的任何锁，直到事务获取了它所需的所有锁。
  *   **解锁阶段（Unlocking Phase）：** 一旦事务开始释放锁，它就不能再获取任何新的锁，直到完成所有操作。
  *   **违反协议的例子：** 在解锁阶段获取锁。
  *   **两阶段锁的本质：** 通过限制加锁和解锁的顺序来保证事务的可串行化。
  *   **问题：**可能产生死锁或饿死。

### 4.4.2 锁的问题和解决方案

1. **饿死**：锁导致等待，等待可以很久，导致饿死。**饿死避免机制：** 先来先服务策略。

   *   **锁的实现数据结构：哈希表**
       *   `key`：数据项；`value`：锁信息（持有锁的事务及锁类型）。
   *   直接上锁无法解决不可重复读以及写冲突等问题。
   
2. **死锁**：事务互相等待对方释放锁，导致所有事务都无法继续执行。
   *   **死锁的解决办法：**
       *   **死锁预防：** 不允许互相等待。
       *   **Wait-Die策略：** 如果`Tn`持有锁，`To`申请锁，那么`To`等待；如果`To`持续锁，`Tn`申请锁，那么`Tn`被撤销，但重启之后保留原来的时间戳。
       *   **Wound-Wait策略：** 如果`Tn`持有锁，`To`申请锁，那么`Tn`被撤销，重启后保留原来的时间戳；如果`To`持续锁，`Tn`申请锁，那么`Tn`等待。
       *   **Wait-Die和Wound-Wait对比：**

        |            |          | Tn申请锁 | To申请锁 |
        | :--------- | -------- | :------- | :------- |
        | Wait-Die   | Tn持有锁 | /        | To等待   |
        |            | To持有锁 | Tn被撤销 | /        |
        | Wound-Wait | Tn持有锁 | /        | Tn被撤销 |
        |            | To持有锁 | Tn等待   | /        |
        *   应该把优先级给更早的事务。
        *   保留时间戳是为了避免事务因为不断被撤销而无法完成。
    *   **死锁检测与恢复：**
        *   检测事务依赖环（会产生额外的资源开销）。
        *   当检测到环的时候，撤销一个事务作为牺牲者，根据：事务开始运行的时间戳；事务已经执行的SQL语句数量；事务已经加锁的数据项的数量。
    *   **设锁超时重启：**
        *   设置事务最长等待时间。
        *   如果申请加锁的事务在该时间结束时仍未获得锁，即事务超时，那么此时将该事务回滚并重启。
        *   当事务之间确实存在死锁时，该方法会让死锁中的一个或者多个事务回滚并重启，而其他事务继续执行，解决了死锁问题。
        *   适用场景：事务执行时间都比较短；事务长时间的等待大多都是死锁造成的。

### 4.4.3 锁的粒度

*   **锁的粒度：** 数据项的粒度：属性、元组、表、整个数据库。
* 锁的粒度基于数据项的粒度。

  *   粒度越大，数据项越少，管理锁的开销越小；事务之间发生冲突的可能性越大，并发度越低。
  *   粒度越小，系统开销越大，并发度越高。

* **多粒度锁**

  <img src=".\assets\image-20241231224019581.png" alt="image-20241231224019581" style="zoom:33%;" />

  *   数据库中的所有对象按照大小的不同构成了一棵多粒度树。
  *   多粒度树中的每一个节点可以独立地加锁。
  *   对某个节点加锁表示对该节点的后代节点加同类型的锁（隐式锁）。
  *   **数据项的两种加锁状态：**
      *   **显式锁：** 该数据项被直接加上的锁。
      *   **隐式锁：** 该数据项没有被直接加锁，由于其祖先节点被加锁而变为加锁状态。
* **意向锁：**
  *   提供了一种对某个数据项读写的“意向”，相比于普通锁有更高的并发性。
  *   使用时，对多粒度树中任一节点加锁时，需要先对其所有祖先点加意向锁。
  *   **意向共享锁（IS锁）：** 如果要对某个数据项加共享锁，先对其祖先点加意向共享锁。
  *   **意向互斥锁（IX锁）：** 如果要对某个数据项加互斥锁，先对其祖先点加意向互斥锁。
  *   **共享意向互斥锁（SIX锁）：** 表示共享锁+IX锁。对某数据项加SIX锁，表示在对该数据项显式加共享锁的同时加IX锁。
  *   **意向锁设计的目的：**允许同时读写一个大粒度（表）下的细粒度数据项。
  *   **意向锁相容性表格：**

|                | 共享锁 | 互斥锁 | 意向共享锁 | 意向互斥锁 | 共享意向互斥锁 |
| :------------- | :----- | :----- | :--------- | :--------- | :------------- |
| 共享锁         | 相容   | 不相容 | 相容       | 不相容     | 不相容         |
| 互斥锁         | 不相容 | 不相容 | 不相容     | 不相容     | 不相容         |
| 意向共享锁     | 相容   | 不相容 | 相容       | 相容       | 相容           |
| 意向互斥锁     | 不相容 | 不相容 | 相容       | 相容       | 不相容         |
| 共享意向互斥锁 | 不相容 | 不相容 | 相容       | 不相容     | 不相容         |

*   **谓词锁：** 作用于满足特定条件的所有对象，例如`age > 17`的谓词锁作用于所有满足该条件的元组。（**幻读的解决方案**）
    *   **读取（`select`）：** 如果事务`T1`想读取满足某谓词的对象，则该事务需要获得相应的谓词锁。若此时事务`T2`正在持有满足该谓词的某个对象的互斥锁，则`T1`需要等到`T2`释放该互斥锁，才能加谓词锁，并继续执行查询。事务`T1`提交或回滚时释放持有的所有谓词锁。
    *   **插入、更新和删除（`insert`, `update`, `delete`）：** 如果事务`T1`想要插入、更新或删除一些对象，需要检查这些对象的旧值和新值是否与现有的谓词锁匹配。如果与某些谓词锁匹配，则需要等待这些谓词锁释放，之后事务`T1`才能继续执行。
*   **索引区间锁：** 一种在数据库索引上施加的锁，用于锁定一个特定的索引键值范围。这种锁不仅锁定实际存在的索引键值，还包括这个范围内可能插入的未来键值。
    *   **性能分析：**
        *   索引区间锁的检查与索引更新同步，开销较小。
        *   索引区间锁扩大了锁的范围，导致更多锁冲突和等待。
        *   是一种折衷的方法。

## 4.3 调度

1. **调度 (Schedule)**
   
    *   **定义:** 并发事务的执行过程中，所有事务中操作的执行顺序。
    *   **类型:** 并发调度、串行调度
    
2. **可串行化调度 (Serializable Schedule)**
   
    *   **定义:** 给定一个并发调度 S，存在一个串行调度 S'，在任何数据库状态下，按照调度 S 和 S' 执行后所产生的结果都是相同的。
    *   **重要性:** 如果一个调度是可串行化的，理论上可以不需要锁机制。
    *   判定可串行化调度的算法复杂度非常高，为$O(N!)\approx O\left(\sqrt{2\pi N}\left(\frac Ne\right)^N\right)$。
    
3. **冲突可串行化调度**
   
    *   **交换:** 一个调度中时间上不同事物上相邻两个操作的顺序置换。
    *   **等价操作:** 交换后不影响调度一致性的操作。
        *   对相同或不同数据项的读操作: R(A), R(A); R(A), R(B)
        *   对不同数据项的读写操作: R(A), W(B); W(A), R(B); W(A), W(B)
    *   **非等价操作:** 交换后会影响调度一致性的操作。
        *   对相同数据项的读写操作: R(A), W(A); W(A), R(A); W(A), W(A)
    *   **定义:** 给定一个调度 s，如果可以通过一系列等价操作将 s 变换成一个串行调度 s'，那么我们称 s 为一个冲突可串行化调度。
    *   **验证方法:**
        *   构建优先图：节点表示事务，边表示冲突交换。
        *   如果存在等价串行调度 s'，则优先图中，有冲突的事务之间存在先后关系。
        *   **优先图无环的调度即为冲突可串行化的调度。**
        
        <img src=".\assets\image-20250103113456870.png" alt="image-20250103113456870" style="zoom:33%;" />
    
4. **视图可串行化调度**
   
    *   **定义:** 每个事务读取（看到）数据的结果必须与它在某个序列化执行顺序中读取的结果相同。
    *   **判断条件:** 如果存在一个串行调度 s' 与目标视图等价，那么对任意数据项 X：
        *   s 与 s' 需要读取相同的 X 的初始值
        *   s 与 s' 需要读取相同的 X 的更新值
        *   s 与 s' 需要最后写入相同的 X 的更新值
    *   **验证方法 (改进的优先图):**
        *   引入虚拟事务 T0（写入所有数据项的初始值）和 Tn+1（读取所有数据项的最终值）。
        *   数据流：如果 Tj 读取了 Ti 写的变量，那么从 Ti 指向 Tj，意味着 Ti 需要先于 Tj 发生。
        *   初始化数据项的事务需要优先执行，最后写入数据项的事务需要最后执行
        *   对于每个事务 T 对数据项的写操作，寻找优先图中其它事务之间的一条数据流边，将 T 插入到数据流前或后。
        *   **只要存在一种优先图无环，则该调度是视图可串行化的。**
    
    <img src=".\assets\PixPin_2025-01-03_13-41-51.png" alt="PixPin_2025-01-03_13-41-51" style="zoom:33%;" />

## 4.4 其他并发控制技术

1. **乐观并发控制技术:**
    *   **假设:** 多个事务同时操作同一数据的几率很低。
    *   **三阶段:**
        *   **读取阶段:** 不锁定数据，允许其他事务并行访问相同数据。
        *   **验证阶段:** 事务准备提交更改时，检查在读取阶段期间是否有其他事务修改了它所读取的数据。
        *   **提交/回滚阶段:** 如果没有冲突（即自事务开始以来数据没有被其他事务更改），则提交更改；如果发现冲突，事务回滚并可能重试。
2. **时间戳排序协议:**
    *   每个事务有一个唯一的时间戳，每个数据项上都记录一个最新的读写记录时间。通过对比事务的时间戳和所要读写的数据项上的时间戳来决定是否执行或者回滚事务。
    *   **事务读:** T 只能读 T 之前的事务写的数据。
    *   **事务写:** T 只能写 T 之前读写的数据。
    *   **ts(T):** 事务 T 的时间戳。
    *   **ts(R\*(X)):** 数据项 X 被最新一次读取的事务的时间戳。
    *   **ts(W\*(X)):** 数据项 X 被最新一次写入的事务的时间戳。
    *   若违反规则，则重启事务。
3. **多版本机制:**
    *   **多版本并发控制:** 对于一个数据项，保存多个物理版本，供不同的事务使用。
    *   **基本原则:**
        *   事务对数据项进行写操作时，产生该数据项的一个新版本。
        *   事务对数据项进行读操作时，读取事务开始时该数据项的最新版本。
    *   **优点:**
        *   事务的读操作无需等待其他事务的写操作。
        *   事务的写操作无需等待其他事务的读操作。

# 5. 数据库恢复

## 5.1 数据库故障 (不考)

1. **故障的类型**:
    *   **事务故障 (Transaction failures)**: 由于资源冲突或死锁导致事务执行失败。
    *   **系统故障 (System failures)**: 数据库自身或操作系统故障导致数据库进程意外退出。
    *   **磁盘故障 (Storage media failures)**: 磁盘损坏导致数据无法读取。
    *   **自然灾害**: 对数据库系统所在环境造成彻底破坏。
2. **数据库故障与恢复机制对应关系**:
    *   **事务故障**: 故障恢复机制 (原子性)
    *   **系统故障 (可重启)**: 故障恢复机制 (原子性/持久性)
    *   **磁盘故障**: 数据多副本 (持久性)
    *   **系统故障 (不可重启)**: 一主多备 (持久性)
    *   **自然灾害**: 异地多机恢复 (持久性)
3. **数据备份**:
    *   **磁盘数据丢失**: RAID 技术、Paxos 技术，单机数据多副本。
    *   **机器不能重启**: 备份数据库 (或数据库 + 日志)，一主多备。
    *   **异地容灾**: 在同城、异地建立数据备份中心，比主备模式更安全，但数据同步代价高，多节点数据一致性是挑战。

## 5.2 缓冲池策略

1. **系统故障恢复的两种操作**
    *   **Undo**: 撤销未完成事务对数据库的修改。
    *   **Redo**: 重做已提交事务对数据库的修改。
2. **STEAL/NO-STEAL 策略**
    *   **STEAL**: 允许将未提交事务所做的修改写到磁盘并覆盖现有数据。
    *   **NO-STEAL**: 不允许将未提交事务所做的修改写到磁盘并覆盖现有数据。
3. **FORCE/NO-FORCE 策略**
    *   **FORCE**: 强制事务在提交前必须将其所做的修改全部写回磁盘。
    *   **NO-FORCE**: 不强制事务在提交前必须将其所做的修改全部写回磁盘。
4. **四种缓冲池策略的 I/O 效率和缓冲池效率**
    *   **NO-STEAL + FORCE**: I/O 效率低，缓冲池效率低。
    *   **NO-STEAL + NO-FORCE**: I/O 效率高，缓冲池效率低。
    *   **STEAL + FORCE**: I/O 效率低，缓冲池效率高。
    *   **STEAL + NO-FORCE**: I/O 效率高，缓冲池效率高 (大多数 DBMS 采用)。
5. **四种策略的优缺点**
    *   **NO-STEAL 缺点**: 事务执行过程中不能刷盘，占用较大的缓冲区空间，不利于并发。
    *   **FORCE 缺点**: 事务完成必须刷脏，导致占用大量 I/O 读写。

|                      |             FORCE (事务完成强制刷盘)           |   NO-FORCE (事务完成非强制刷盘)           |
| :------------------- | :---------------------------------------------: | :-----------------------------------------: |
| NO-STEAL (执行期间不刷盘) |   无redo日志 \| 无undo日志       |     有redo日志 \| 无undo日志     |
|  STEAL (执行期间可刷盘)    |   无redo日志 \| 有undo日志     |  有redo日志 \| 有undo日志 |

## 5.3 数据库日志

1. **日志文件 (Log file)**: 记录事务对数据库更新操作的文件，用于事务回滚和重做，实现原子性和持久性。
2. **日志记录 (Log record)**: 日志是日志记录的序列，顺序写入磁盘且不会被修改。
3. **事务的生命周期**: 开始事务 -> 活跃状态 -> 准备提交 -> 提交检查 -> 执行成功/执行失败 -> 事务结束/中止。
4. **Undo 回滚日志**
    *   **格式**: `<T, X, v_old>` (事务标识符，数据项，修改前的值)
    *   **产生时机**: 事务 T 修改数据项 X 时产生。
    *   **作用**: 实现事务回滚。
    *   **内容**: 通常还包含日志序号 (LSN)。
5. **Redo 重做日志**
    *   **格式**: `<T, X, v_new>` (事务标识符，数据项，修改后的值)
    *   **产生时机**: 事务 T 修改数据项 X 时产生。
    *   **作用**: 实现事务重做。
6. **预写日志 WAL (Write Ahead Logging)**:
    *   日志必须比数据更早地写入磁盘。
    *   日志写回磁盘的顺序必须和日志生成的时间一致。
    *   `<T commit>` 写入磁盘后，事务才算 commit。
    *   **核心思想**: DBMS 在将修改过的数据写到磁盘之前，必须先将修改此数据的日志记录写到磁盘。
7. **基于 WAL 的故障恢复两个阶段**:
    *   **事务正常执行时的行为**: 记录日志，按照缓冲池策略将修改过的对象写到磁盘。
    *   **故障恢复时的行为**: 根据日志和缓冲池策略，对事务进行 Undo 或 Redo。

## 5.4 故障恢复机制

1. **事务的分类**:
    *   **已提交事务**: 既有 `<T, start>`，又有 `<T, commit>`。
    *   **不完整事务**: 只有 `<T, start>`，没有 `<T, commit>`。
    *   **已中止事务**: 既有 `<T, start>`，又有 `<T, abort>`。 (说明修改已全部撤销，相当于未执行过，无需 Undo，更不需要 Redo)

2. **故障恢复时的行为**:
    *   **已提交事务**: 如果修改已全部写入磁盘，则无需 Redo；否则需要 Redo。
    *   **不完整事务**: 如果任何修改都未写入磁盘，则无需 Undo；否则需要 Undo。
    *   **总结**: 缓冲池策略决定了上述行为。

3. **影子拷贝方法 (NO-STEAL + FORCE)**:
    *   事务修改在拷贝数据库 (或影子拷贝页面) 上。
    *   提交事务时，切换数据库指针。
    *   **优点**: 影子页面，仅拷贝修改的页面。
    *   **缺点**: 效率低，难以支持事务并发。

    <img src=".\assets\image-20250102225611255.png" alt="image-20250102225611255" style="zoom:33%;" />

4. **基于 Undo 日志的恢复 (WAL + STEAL + FORCE)**:
    *   不需要处理事务重做，依靠 Undo 日志回滚事务。
    *   **故障恢复任务**: 找到未提交事务，回滚这些事务，写入事务中止日志。
    *   **事务正常执行时的行为**: 
        1. 事务开始 `<T, start>`
        2. 修改数据项 `<T, X, v_old>`，修改过的脏页允许写入磁盘（STEAL），但必须先将脏页对应的undo日志写入磁盘
        3. Commit 事务 `<T, commit>`，将T关联的脏页及undo日志写入磁盘
        4. Abort 事务 `<T, abort>`，将T关联的脏页及undo日志写入磁盘

    <img src=".\assets\image-20250102230502988.png" alt="image-20250102230502988" style="zoom:33%;" />

    *   **恢复流程**
        1. 识别出需要回滚的事务
           * 已提交的事务：包含`<T, start>`且包含`<T, commit>`的事务：FORCE，不需要被回滚
           * 不完整的事务：只包含`<T, start>`但不包含`<T, commit>`的事务：STEAL，需要被回滚（undo）
        2. 回滚所有不完整的事务：从后向前逆序扫描整个undo日志，根据每条日志记录的类型执行相应的动作
           * `<T, commit>`：将T记录为已提交事务（无需undo）
           * `<T, abort>`：将T记录为已中止事务（无需undo）
           * `<T, X, v_old>`：如果T是不完整事务，则将磁盘上X的值恢复为v_old
           * `<T, start>`：如果T是不完整事务，表示T恢复完毕，向日志中写入`<T, abort>`（今后故障恢复时无需再undo）

5. **基于 Redo 日志的恢复 (WAL + NO-STEAL + NO-FORCE)**:

    *   不需要处理事务回滚，依靠 Redo 日志重做事务。
    *   **故障恢复任务**: 找到已提交事务，重做这些事务，写入事务结束日志。
    *   **事务正常执行时的行为**
        1. 事务开始 `<T, start>`
        2. 修改数据项 `<T, X, v_new>`，未提交事务修改过的脏页不允许写入磁盘（NO-STEAL）
        3. Commit 事务 `<T, commit>`，T关联的脏页（且该脏页无相关未提交事务）允许写入磁盘（NO-FORCE）
        4. Abort 事务 `<T, abort>`，失效缓冲区内该事务修改的页面

    <img src=".\assets\image-20250102231812170.png" alt="image-20250102231812170" style="zoom:33%;" />

    *   **恢复流程**

        1. 识别出需要回滚的事务

           * 已提交的事务：包含`<T, start>`且包含`<T, commit>`的事务：NO-FORCE，已提交事务所做的修改可能尚未全部写入磁盘（undo）
           * 不完整的事务：只包含`<T, start>`但不包含`<T, commit>`的事务：NO-STEAL，不完整事务所做的任何修改都未写入磁盘，添加`<T, abort>`

        2. 从前向后顺序扫描整个redo日志两遍

           第1遍扫描：记录已提交事务和已中止事务

             * `<T,commit>`: 将T记录为已提交事务(需要redo)
             * `<T,abort>`:将T记录为已中止事务(无需redo)

           第2遍扫描：根据每条日志记录的类型执行相应的动作

             * `<T, X, v_new>`:如果T是已提交事务,则将磁盘上X的值覆写为vnew
             * `<T,start>`:如果T不完整,向日志中写入<T,abort>

    *   **基于 Redo 日志的问题**: 事务执行期间不能刷盘，内存占用大，事务并发受限。

6. **基于 Undo/Redo 日志的恢复 (WAL + STEAL + NO-FORCE)**:
    * 依靠 Undo 日志处理事务回滚，依靠 Redo 日志处理事务重做。

    * **故障恢复任务**: 找到需要重做和回滚的事务 (分析阶段)，重做已提交事务 (重做阶段)，回滚不完整事务 (撤销阶段)。

    * **事务正常执行时的行为**

      1. 事务开始 `<T, start>`
      2. 修改数据项 `<T, X, v_old, v_new>`，修改过的脏页允许刷盘（STEAL）
      3. Commit 事务 `<T, commit>，`，并且将日志刷盘，页面可不刷盘（NO-FORCE）
      4. Abort 事务 `<T, abort>`，并且将日志刷盘，页面可不刷盘（NO-FORCE）

      <img src=".\assets\image-20250102233109183.png" alt="image-20250102233109183" style="zoom:33%;" />

    * **恢复流程**

      1. 识别需要重做和回滚的事务
            - 已提交的事务: 包含`<T,start>`且包含`<T,commit>`：NO-FORCE，已提交事务所做的修改可能尚未全部写入磁盘 (redo)
            - 不完整的事务: 只包含`<T,start>`但不包含`<T, commit`>：STEAL，不完整事务所做的一部分修改可能已经写入磁盘 (undo)
      2. 系统从日志起始位置开始扫描整个日志，找出需要重做和需要回滚的事务。

           *   在扫描过程中出现`<T start>`的日志记录而没有`<T commit>`或`<T abort>`，那么该事务在数据库崩溃的时刻是不完整的，需要被回滚（标注回滚）。
           *   在扫描过程中出现了`<T commit>`，那么事务已经提交，需要被恢复子系统重做（标注重做）。
      3. 系统按时间顺序**正向**扫描日志，如果出现了一条标注重做的日志记录，系统便重做它。
         * 由于系统重做了所有的日志更新记录，这个过程和数据库的执行历史是相同的，因此该过程也被称作重放历史(repeating history)。

      4. 从日志末尾**反向**扫描整个日志，如果出现了一条标注撤销的日志记录，那么系统会撤销它（包括修改缓冲池）。
         * 一旦事务撤销完成 (即扫描中遇到了`<T start>`)，数据库会自动写入`<T abort>`，代表该事务已经回滚完成。

7. **检查点机制**:
    *   数据库日志不断变长，恢复时间变长，需要压缩日志。
    *   **检查点 (Checkpoint)**: 定义脏页刷盘时刻，要求检查点之前的日志记录对应的缓冲区数据页面修改已刷新到磁盘。

8. **全量检查点**:
    *   停止接受新的事务或修改请求。
    *   将当前所有未写入磁盘的脏数据页写入磁盘 (全量刷脏)。
    *   记录 Checkpoint 检查点。
    *   恢复接受新的事务或修改请求。

9. **涉及检查点的故障恢复**:
    *   定位到检查点时刻的日志。
    *   **三种情况**: 检查点之前完成 (commit/abort) 的事务不需要处理，检查点之后完成 (commit) 的事务需要重做，未完成事务 (不含 commit/abort) 需要回滚。
    *   数据库管理系统会定时或手动执行检查点操作。

10. **涉及检查点的故障恢复示例**: 结合图示和具体日志说明如何根据检查点进行恢复。

# 6. 存储和索引

## 6.1 数据库物理存储

### 6.1.1 计算机系统的存储架构

*   **存储层次结构:**
    *   从高到低依次为：缓存(cache), 主存(main memory/RAM), 闪存(flash memory/SSD), 磁盘(hard disk drive/HDD), 光盘(optical disks), 磁带(magnetic tapes)
    *   访问速度、成本、容量、可靠性在不同层次上的变化趋势
*   **存储类型:**
    *   主存储器 (primary storage): 按字节寻址 (byte-addressable)，包括寄存器 (register)、高速缓存 (cache)、内存 (main memory)
    *   二级存储器 (secondary storage): 按块寻址 (block-addressable)，包括磁盘 (magnetic disk)、固态硬盘 (SSD)
    *   三级存储器 (tertiary storage): 按块寻址 (block-addressable)，包括磁带 (magnetic tape)、光盘 (optical disk)、网络存储 (network storage)
*   **访问时间:**
    *   不同存储介质的访问时间对比 (L1 cache, L2 cache, DRAM, SSD, HDD, 网络存储, 磁带)
    *   内存的优缺点：容量小、价格高、易失性
*   **存储层次之间的数据传输:**
    *   Cache 与 DRAM 之间以缓存行 (cache line) 为单位，大小通常为 64B
    *   DRAM 与二级存储器、二级存储器与三级存储器之间以块 (block) 或页 (page) 为单位，大小通常为 512B-16KB
    *   局部性原理：时间局部性 (temporal locality) 和空间局部性 (spatial locality)

**2. 磁盘 (Disk)**

*   **物理结构:** 盘面 (platter), 磁道 (track), 扇区 (sector)
*   **磁盘最小读写单位:** 扇区
*   **磁盘块/页 (block/page):** 连续的若干个扇区，大小通常为 512B-16KB
*   **磁盘容量计算:** 示例
*   **磁盘页面访问时间组成:** 寻道时间 (seek time)、旋转时间 (rotational latency)、传输时间 (transfer time)
*   **访问特性:** 寻道时间和旋转时间最长；顺序访问比随机访问快

**3. 存储访问**

*   **缓冲池 (buffer pool):** 内存中用来缓存磁盘页面的区域
*   **缓冲池管理器 (buffer manager):** 管理内存和磁盘之间的数据传输
*   **缓冲池管理器的目标:** 减少磁盘总访问次数或缩短磁盘总访问时间
*   **页面替换策略:**
    *   最近最少使用策略 (LRU, Least Recently Used)
    *   LRU 在特定访问模式下的性能问题 (例如：嵌套循环连接)
    *   最近最多使用策略 (MRU, Most Recently Used)

### 6.1.2 记录的组织方式

*   **数据库的数据组织:**
    *   数据库以一组文件 (files) 的形式存储
    *   文件是包含多条记录 (records) 的序列
    *   记录是包含多个字段 (fields) 的序列
    *   常见组织方式：定长记录、每文件仅一种类型记录、不同表格不同文件
    
* **记录的表示:**

  <img src=".\assets\image-20241231231743242.png" alt="image-20241231231743242" style="zoom:33%;" />

  *   字节序列 (a sequence of bytes)
      *   DBMS 根据记录所在关系的模式，将字节序列翻译为记录的属性值
      *   DBMS 的系统目录 (catalog) 记录关系的模式定义
  *   记录包含两部分：记录头 (header) 和记录数据 (data)
  *   记录头包含元数据 (meta-data): 模式定义指针、记录长度、最后修改时间、可见性、属性值非空位图 (bitmap) 等
  *   记录数据由所有属性值拼接而成，通常按属性顺序存储，偏移量是 4 字节或 8 字节的倍数

* **变长记录的布局:** 定长属性和变长属性分别置于记录两端，记录头后紧跟指针数组，指向每个属性值

*   **页布局:** 页头 (page header) 和页数据 (page data)；页头记录页的元数据；页数据采用分槽页 (slotted page) 组织记录，包含槽数组 (slot array) 和记录序列

<img src=".\assets\image-20241231231707725.png" alt="image-20241231231707725" style="zoom:33%;" />

### 6.1.3 文件的组织方式

*   **需要考虑的因素:** 更新 (增、删、改) 和检索需求；数据存储空间的扩展与回收；扫描整个数据库和大批量数据处理；不同的需求对应不同的文件组织方式
*   **无序记录文件 (堆文件 heap/pile file):**
    *   记录存储于任意有空间的位置，磁盘上记录无序
    *   插入和删除操作 (两种方法)
        *   方法1：新记录总插入到文件尾部；删除记录时，可以直接删除该记录所在位置的内容，也可以在该记录前标记“删除标记”
        *   方法2：在前者基础上，新增记录可以利用那些标记为“删除标记”的记录空间
    *   数据库重组 (reorganization)：通过移走被删除的记录使有效记录连续存放，从而回收那些由删除记录而产生的未利用空间。
    *   页的组织方式：基于链表和基于页目录
*   **有序记录文件 (排序文件 sequential):**
    *   记录按某属性或属性组值的顺序插入，磁盘上记录有序
    *   排序字段 (ordering field)：用于存储排序的属性，通常使用关系中的主码， 所以又称排序码 (ordering key)
    *   检索效率：按排序字段检索效率高，按非排序字段检索效率无提升
    *   更新效率低 (移动记录、预留空间、溢出文件)
    *   数据库重组：将溢出文件合并到主文件中，并恢复主文件中的记录顺序。
        *   为将来有可能插入的记录预留空间(这可能造成空间浪费)，或者再使用一个临时的无序文件(被称为溢出文件)保留新增的记录。当采取溢出文件措施时，检索操作既要操作主文件，又要操作溢出文件，所以需要周期性重新组织数据库。
*   **散列文件 (hash file):**
    *   根据散列函数确定记录存储在哪个页
    *   散列字段 (hash field)：用于进行散列函数计算的属性，通常也采用关系中的主码，所以又称散列码(hash key)

## 6.2 数据库索引

### 6.2.1 索引概述

* **索引的目的:** 用于从数据库中高效获取满足条件的记录 (加速数据获取速度)

* **索引的原理:** 通过存储 (查找键, 数据位置) 来快速定位记录

*   **索引按照物理存储类型分类:**
    *   聚集索引 (Clustered Index): 数据按照查找键排序，一张表只能有一个。按照查找键连续存储，范围查询效率高；维护增删时需要移动数据文件中的记录，开销稍大。
    *   非聚集索引 (Nonclustered Index): 辅助索引、二级索引，一张表可以有多个，数据不一定按照索引列顺序存储
    
    <img src=".\assets\image-20241231232622913.png" alt="image-20241231232622913" style="zoom:33%;" />
    
*   **索引按照指针记录的粒度分类:**
    
    *   稠密索引 (Dense Index): 索引到数据记录 (非聚集索引一定是稠密索引)
    *   稀疏索引 (Sparse Index): 索引到文件页面 (聚集索引通常是稀疏索引)
    
    <img src=".\assets\image-20241231232643939.png" alt="image-20241231232643939" style="zoom:33%;" />
    
*   **索引按照层数分类:**
    *   单级索引：如哈希
    *   多级索引：如 B+ 树，索引文件上再建索引
    
*   **索引按照字段特性分类:**
    *   主键索引：建立在主键字段上的索引，一张表最多只有一个，索引列不允许空值
    *   唯一索引：建立在 UNIQUE 字段上的索引，一张表可以有多个，索引列值必须唯一，但允许空值
    *   普通索引
    
*   **索引按照字段个数分类:**
    
    *   单列索引：建立在单个字段上的索引
    *   多列索引：建立在多个字段上的索引
    
    <img src=".\assets\image-20241231232733717.png" alt="image-20241231232733717" style="zoom:33%;" />
    
*   **索引类型与查询类型:**
    *   点查询：哈希索引、B+ 树索引
    *   范围查询：B+ 树索引
    *   多列条件查询：位图索引
    *   空间范围查询、最近邻查询：多维索引 (R 树、Quadtree、KD 树)

### 6.2.2 B+ 树索引

*   **索引结构:**
    
    *   平衡多叉查找树，根到所有叶子节点路径长度相同
    *   扇出 m (fan-out): 每个节点最多分叉数
    *   子节点数目范围: [⌈m/2⌉, m]
    *   查找键数目范围: [⌈m/2⌉-1, m-1]
    *   根节点的特殊情况：如果根不是叶子节点，至少2个子节点；如果根是叶子节点，有[0, m-1]查找键。
    
    <img src=".\assets\image-20241231232843813.png" alt="image-20241231232843813" style="zoom:33%;" />
    
*   **节点：页面 (磁盘索引)**
    *   页面缓冲管理器
    *   节点内指针：内部节点 (索引页面号)；叶子节点 (数据记录页面号，数据记录槽号)
    
    <img src=".\assets\image-20241231232931865.png" alt="image-20241231232931865" style="zoom:33%;" />
    
*   **特性:**
    *   Tree(Pi) < Ki ≤ Tree(Pi+1)
    *   扇出 m 由页面大小和键值大小决定，通常 m 为 200~300
    *   10 亿条记录仅需 4~5 层
    *   I/O 次数少
    
*   **查找算法:**
    *   点查询 (point query): 从根节点逐层加载索引页面到缓冲区，直到叶子节点；内部节点存在的键，叶子节点中不一定存在
    *   区间查询 (range query) [L, U]: 叶节点兄弟之间有指针；首先根据查找键查找左端点；然后按照节点指针向右线性扫描
    
    <img src=".\assets\image-20241231234306098.png" alt="image-20241231234306098" style="zoom:33%;" />
    
*   **插入算法:**
    *   找到应插入的叶子节点 L
    *   将索引记录插入到 L 中
    *   如果 L 有多余空间，结束；否则，需要分裂 L
    *   叶节点分裂：将节点内容均分为两部分，假设 L 中间键为 K'（第⌈m/2⌉+1个元素），L 中小于 K' 的保存在 L'，大于等于 K' 的移动到 Lnew，将 K' 插入 L 父节点，并更新指向 L' 和 Lnew 的指针，如果 L 父节点溢出，继续分裂
    *   内部节点 (非叶节点) 分裂：中间键 K' （第⌈m/2⌉个元素）不放在新节点中 (L' 和 Lnew)，上移至父节点
    
*   **删除算法:**
    *   找到待删除索引记录所在叶节点
    *   从叶节点中删除索引记录
    *   如果节点中键数目大于等于⌈m/2⌉-1，则结束
    *   如果节点中键数目小于等于⌈m/2⌉-2，发生下溢
    *   尝试从节点相邻的兄弟节点借一个索引项，使两者均至少半满，并更新父节点
    *   如果借不到，则将该节点与其兄弟节点合并
    
*   **节点合并:**
    *   如果节点 L 与左侧兄弟节点 L1 合并，则从 L 的父节点中删除指向 L 的指针及相应的键
    *   如果节点 L 与右侧兄弟节点 L2 合并，则从 L 的父节点中删除指向 L 的指针及相应的键
    *   如果 L 的父节点 N 至少半满，则完成合并；否则处理 N，使 N 至少半满
    *   如果 N 是根节点，且 N 中只有一个指针，则删除 N
    *   如果 N 是内节点，则尝试从 N 相邻的兄弟节点借一个指针和键，使两者均至少半满；如果借不到，则将 N 与其兄弟节点合并

### 6.2.3 哈希索引

*   **哈希函数:**
    *   给定查找键，返回一个整数表示 (哈希值)，用于确定查找键在哈希表中的位置
    *   常见的哈希函数：MD5, SHA256, CRC-64, PostgreSQL Lookup3Hash, MurmurHash, Google CityHash, Facebook RocksDB XXHash
*   **哈希表:**
    *   持续向哈希表插入数据，桶溢出不可避免
    *   连接空页面形成链表会降低查找性能
    *   **静态哈希表:** 桶数固定，溢出时需要分配更多桶，重新哈希
        *   闭哈希：当插入哈希值满时，寻找空位置 (线性探测 +i，平方探测 +i²)
        *   开哈希：当插入哈希值满时，新建哈希桶，通过哈希桶链表链接
    *   **动态哈希表:** 动态调整桶数的哈希表 **(不考)**
        *   **可扩展哈希表**
        *   **线性哈希表**
    *   可扩展哈希表的问题:
        *   哈希表每次容量加倍时需要阻塞对整个哈希表的访问，降低了系统性能
        *   如果少量桶多次溢出，则需要频繁对哈希表进行扩容，造成一部分桶空，导致空间浪费

# 7. 查询处理与优化

- **查询处理步骤**

  1. **查询解析**:

     - 将 SQL 查询语句转换为查询树。
     - 叶子节点：表或视图。
     - 内部节点：关系代数操作符。
     - 根节点：输出最终结果。

     <img src=".\assets\image-20241231235415686.png" alt="image-20241231235415686" style="zoom:33%;" />

  2. **查询优化**:

     - **逻辑优化**: 依据逻辑等价变换规则将关系代数表达式变换为更高效的形式。（**调整查询树**）通过调整关系代数运算顺序来最小化每步运算要处理的行数。
     - **物理优化**: 依赖于代价估计器估计各执行计划的代价，从中选取资源消耗最小的执行计划。基于物理参数（如缓存大小等）估计数据库的数据规模（如数据块大小等），从而估计计划执行的代价，并从众多候选计划中选择代价最小的计划。
     - **代价估计**: 用来预测各执行计划的资源消耗大小。

- **查询解析步骤**

  1. **词法分析**: 提取 SQL 语句中的关键词、标识符、常量、运算符、分隔符等成分。
  2. **语法分析**: 将词法分析提取的成分构建为一颗语法分析树 (遵循 BNF 范式)。
  3. **语义分析**: 检查语法分析树的语义正确性，并将其转化为基于关系代数式表达的查询树。
     * 对关系（表名）的检查：检查查询中出现的关系是否在关系模式中能找到匹配的关系或视图
     * 对属性（列名）的检查：检查查询中涉及的属性是否能在数据库关系中找到匹配项
     * 对数据类型的检查：检查查询中的运算是否与涉及的属性类型相匹配

- **逻辑优化 (查询重写)**

  - **重写规则**:
    - 下推谓词: σ<sub>p</sub>(R₁ × R₂) = σ<sub>p</sub>(R₁) × R₂
    - 尽早做投影: Π(R₁ × R₂) = Π(R₁) × Π(R₂)
    - 尽可能避免笛卡尔积: σ<sub>p</sub>(R₁ × R₂) = R₁ ⋈<sub>p</sub> R₂
    - 常数折叠/常数传播: A = B and A > 5 → B > 5
    - 去除非必要谓词: max(distinct A) → max(A)
  - **核心思想**: 尽可能将临时表变得越小越早越好。
  - **技巧**: 
    - 选择下推
    - 投影下推
      - **投影下推 (多次投影)**: 若 S₁ ⊆ S₂ 且都是关系 R 的属性，则 Π<sub>S₁</sub>(Π<sub>S₂</sub>(R)) = Π<sub>S₁</sub>(R)
      - **投影下推 (结合选择)**: 若选择条件 p 只涉及投影 S 中的属性，则 σ<sub>p</sub>(Π<sub>S</sub>(R)) = Π<sub>S</sub>(σ<sub>p</sub>(R))
      - **投影下推 (针对笛卡尔积)**: Π<sub>S₁∪S₂</sub>(R₁ × R₂) = Π<sub>S₁</sub>(R₁) × Π<sub>S₂</sub>(R₂)，其中投影属性集合 S₁ 和 S₂ 分别是 R₁ 和 R₂ 中的属性
      - **投影下推 (针对集合并)**: Π<sub>S</sub>(R₁ ∪ R₂) = Π<sub>S</sub>(R₁) ∪ Π<sub>S</sub>(R₂)

| 序号 | 等价转换规则                                                 |
| :--: | :----------------------------------------------------------- |
|  1   | R₁ × R₂ = R₂ × R₁                                            |
|  2   | (R₁ × R₂) × R₃ = R₁ × (R₂ × R₃)                              |
|  3   | R₁ ⋈ R₂ = R₂ ⋈ R₁                                            |
|  4   | (R₁ ⋈ R₂) ⋈ R₃ = R₁ ⋈ (R₂ ⋈ R₃)                              |
|  5   | R₁ ∪ R₂ = R₂ ∪ R₁                                            |
|  6   | (R₁ ∪ R₂) ∪ R₃ = R₁ ∪ (R₂ ∪ R₃)                              |
|  7   | R₁ ∩ R₂ = R₂ ∩ R₁                                            |
|  8   | (R₁ ∩ R₂) ∩ R₃ = R₁ ∩ (R₂ ∩ R₃)                              |
|  9   | σ<sub>p1 ∧ p2</sub>(R) = σ<sub>p1</sub>(σ<sub>p2</sub>(R))   |
|  10  | σ<sub>p1 ∧ p2</sub>(R) = σ<sub>p2</sub>(σ<sub>p1</sub>(R))   |
|  11  | 当 R 为集合时，σ<sub>p1 ∨ p2</sub>(R) = σ<sub>p1</sub>(R) ∪ σ<sub>p2</sub>(R) |
|  12  | σ<sub>p</sub>(R₁ ∪ R₂) = σ<sub>p</sub>(R₁) ∪ σ<sub>p</sub>(R₂) |
|  13  | σ<sub>p</sub>(R₁ - R₂) = σ<sub>p</sub>(R₁) - R₂              |
|  14  | σ<sub>p</sub>(R₁ - R₂) = σ<sub>p</sub>(R₁) - σ<sub>p</sub>(R₂) |
|  15  | 若关系 R₁ 包含选择条件 p 涉及的所有属性，则 σ<sub>p</sub>(R₁ × R₂) = σ<sub>p</sub>(R₁) × R₂ |
|  16  | 若关系 R₁ 包含选择条件 p 涉及的所有属性，则 σ<sub>p</sub>(R₁ ⋈ R₂) = σ<sub>p</sub>(R₁) ⋈ R₂ |
|  17  | 若关系 R₁ 包含选择条件 p 涉及的所有属性，则 σ<sub>p</sub>(R₁ ∩ R₂) = σ<sub>p</sub>(R₁) ∩ R₂ |
|  18  | 若 S₁ ⊆ S₂ 且都是关系 R 的属性，则 Π<sub>S₁</sub>(Π<sub>S₂</sub>(R)) = Π<sub>S₁</sub>(R) |
|  19  | 若选择条件 p 只涉及投影 S 中的属性，则 σ<sub>p</sub>(Π<sub>S</sub>(R)) = Π<sub>S</sub>(σ<sub>p</sub>(R)) |
|  20  | Π<sub>S₁∪S₂</sub>(R₁ × R₂) = Π<sub>S₁</sub>(R₁) × Π<sub>S₂</sub>(R₂)，其中投影属性集合 S₁ 和 S₂ 分别是 R₁ 和 R₂ 中的属性 |
|  21  | Π<sub>S</sub>(R₁ ∪ R₂) = Π<sub>S</sub>(R₁) ∪ Π<sub>S</sub>(R₂) |
|  22  | σ<sub>p</sub>(R₁ × R₂) = R₁ ⋈<sub>p</sub> R₂                 |
|  23  | 等值连接 R₁ ⋈ R₂ = Π<sub>S</sub>(σ<sub>p</sub>(R₁ × R₂))，其中 S 为 R₁, R₂ 属性的并集 |
|  24  | 对于没有重复元素的关系 R, δ(R) = R                           |
|  25  | δ(R₁ × R₂) = δ(R₁) × δ(R₂)                                   |
|  26  | δ(R₁ ⋈ R₂) = δ(R₁) ⋈ δ(R₂)                                   |
